<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BSzF - HF - Buranszki/Tamasy: Sleep Timer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">BSzF - HF - Buranszki/Tamasy
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Sleep Timer</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer structure for sleeptimer.  <a href="structsl__sleeptimer__timer__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtime__date.html">time_date</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time and Date structure.  <a href="structtime__date.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf41c2bc4240e5b819fc7f285f62172a2" id="r_gaf41c2bc4240e5b819fc7f285f62172a2"><td class="memItemLeft" align="right" valign="top"><a id="gaf41c2bc4240e5b819fc7f285f62172a2" name="gaf41c2bc4240e5b819fc7f285f62172a2"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>sl_sleeptimer_timestamp_t</b></td></tr>
<tr class="memdesc:gaf41c2bc4240e5b819fc7f285f62172a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timestamp, wall clock time in seconds. <br /></td></tr>
<tr class="separator:gaf41c2bc4240e5b819fc7f285f62172a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d4d9e5fe98012d2cffedb00caa9c91b" id="r_ga5d4d9e5fe98012d2cffedb00caa9c91b"><td class="memItemLeft" align="right" valign="top"><a id="ga5d4d9e5fe98012d2cffedb00caa9c91b" name="ga5d4d9e5fe98012d2cffedb00caa9c91b"></a>
typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>sl_sleeptimer_timestamp_64_t</b></td></tr>
<tr class="memdesc:ga5d4d9e5fe98012d2cffedb00caa9c91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">sl sleeptimer timestamp 64 t <br /></td></tr>
<tr class="separator:ga5d4d9e5fe98012d2cffedb00caa9c91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27148a3d37b9f3728cbd18b56b4c9979" id="r_ga27148a3d37b9f3728cbd18b56b4c9979"><td class="memItemLeft" align="right" valign="top"><a id="ga27148a3d37b9f3728cbd18b56b4c9979" name="ga27148a3d37b9f3728cbd18b56b4c9979"></a>
typedef int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>sl_sleeptimer_time_zone_offset_t</b></td></tr>
<tr class="memdesc:ga27148a3d37b9f3728cbd18b56b4c9979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time zone offset from UTC(second). <br /></td></tr>
<tr class="separator:ga27148a3d37b9f3728cbd18b56b4c9979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a10efc34059ca887191fbb67ac064b4" id="r_ga5a10efc34059ca887191fbb67ac064b4"><td class="memItemLeft" align="right" valign="top"><a id="ga5a10efc34059ca887191fbb67ac064b4" name="ga5a10efc34059ca887191fbb67ac064b4"></a>
typedef struct <a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sl_sleeptimer_timer_handle_t</b></td></tr>
<tr class="separator:ga5a10efc34059ca887191fbb67ac064b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9049589e4153204fb3e97cbe1ecda89b" id="r_ga9049589e4153204fb3e97cbe1ecda89b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9049589e4153204fb3e97cbe1ecda89b">sl_sleeptimer_timer_callback_t</a>) (<a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *handle, void *data)</td></tr>
<tr class="separator:ga9049589e4153204fb3e97cbe1ecda89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b17c7e32e3ad35bb6b0a9c2001e8d64" id="r_ga8b17c7e32e3ad35bb6b0a9c2001e8d64"><td class="memItemLeft" align="right" valign="top"><a id="ga8b17c7e32e3ad35bb6b0a9c2001e8d64" name="ga8b17c7e32e3ad35bb6b0a9c2001e8d64"></a>
typedef struct <a class="el" href="structtime__date.html">time_date</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sl_sleeptimer_date_t</b></td></tr>
<tr class="memdesc:ga8b17c7e32e3ad35bb6b0a9c2001e8d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time and Date structure. <br /></td></tr>
<tr class="separator:ga8b17c7e32e3ad35bb6b0a9c2001e8d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga147e840cf5d02d54a06e16bccb8e088d" id="r_ga147e840cf5d02d54a06e16bccb8e088d"><td class="memItemLeft" align="right" valign="top"><a id="ga147e840cf5d02d54a06e16bccb8e088d" name="ga147e840cf5d02d54a06e16bccb8e088d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLEEPTIMER_ENUM</b> (sl_sleeptimer_month_t)</td></tr>
<tr class="memdesc:ga147e840cf5d02d54a06e16bccb8e088d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Month enum. <br /></td></tr>
<tr class="separator:ga147e840cf5d02d54a06e16bccb8e088d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1c4c08acb9f670ceb295a6eca059d31" id="r_gae1c4c08acb9f670ceb295a6eca059d31"><td class="memItemLeft" align="right" valign="top"><a id="gae1c4c08acb9f670ceb295a6eca059d31" name="gae1c4c08acb9f670ceb295a6eca059d31"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLEEPTIMER_ENUM</b> (sl_sleeptimer_weekDay_t)</td></tr>
<tr class="memdesc:gae1c4c08acb9f670ceb295a6eca059d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Week Day enum. <br /></td></tr>
<tr class="separator:gae1c4c08acb9f670ceb295a6eca059d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae661a78719a6acc014efa15216ae4a54" id="r_gae661a78719a6acc014efa15216ae4a54"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae661a78719a6acc014efa15216ae4a54">sl_sleeptimer_init</a> (void)</td></tr>
<tr class="separator:gae661a78719a6acc014efa15216ae4a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43c32bdb2a9fcfbe279563a9fd689711" id="r_ga43c32bdb2a9fcfbe279563a9fd689711"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga43c32bdb2a9fcfbe279563a9fd689711">sl_sleeptimer_start_timer</a> (<a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *handle, uint32_t timeout, <a class="el" href="#ga9049589e4153204fb3e97cbe1ecda89b">sl_sleeptimer_timer_callback_t</a> callback, void *callback_data, uint8_t priority, uint16_t option_flags)</td></tr>
<tr class="separator:ga43c32bdb2a9fcfbe279563a9fd689711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacd5a666731a0ba4823107e552e23e69" id="r_gaacd5a666731a0ba4823107e552e23e69"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaacd5a666731a0ba4823107e552e23e69">sl_sleeptimer_restart_timer</a> (<a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *handle, uint32_t timeout, <a class="el" href="#ga9049589e4153204fb3e97cbe1ecda89b">sl_sleeptimer_timer_callback_t</a> callback, void *callback_data, uint8_t priority, uint16_t option_flags)</td></tr>
<tr class="separator:gaacd5a666731a0ba4823107e552e23e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ceb1b76334902525dd32e937e90bb16" id="r_ga2ceb1b76334902525dd32e937e90bb16"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2ceb1b76334902525dd32e937e90bb16">sl_sleeptimer_start_periodic_timer</a> (<a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *handle, uint32_t timeout, <a class="el" href="#ga9049589e4153204fb3e97cbe1ecda89b">sl_sleeptimer_timer_callback_t</a> callback, void *callback_data, uint8_t priority, uint16_t option_flags)</td></tr>
<tr class="separator:ga2ceb1b76334902525dd32e937e90bb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf54408a7f172b684de33d9a7f4e01be9" id="r_gaf54408a7f172b684de33d9a7f4e01be9"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf54408a7f172b684de33d9a7f4e01be9">sl_sleeptimer_restart_periodic_timer</a> (<a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *handle, uint32_t timeout, <a class="el" href="#ga9049589e4153204fb3e97cbe1ecda89b">sl_sleeptimer_timer_callback_t</a> callback, void *callback_data, uint8_t priority, uint16_t option_flags)</td></tr>
<tr class="separator:gaf54408a7f172b684de33d9a7f4e01be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f4f25aa754cd35214dba9762450b0ca" id="r_ga1f4f25aa754cd35214dba9762450b0ca"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1f4f25aa754cd35214dba9762450b0ca">sl_sleeptimer_stop_timer</a> (<a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *handle)</td></tr>
<tr class="separator:ga1f4f25aa754cd35214dba9762450b0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0236c1c353317c41d577867e7429874" id="r_gac0236c1c353317c41d577867e7429874"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac0236c1c353317c41d577867e7429874">sl_sleeptimer_is_timer_running</a> (<a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *handle, bool *running)</td></tr>
<tr class="separator:gac0236c1c353317c41d577867e7429874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a06acb331e2e3c0efeb83f42a4d9c16" id="r_ga6a06acb331e2e3c0efeb83f42a4d9c16"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6a06acb331e2e3c0efeb83f42a4d9c16">sl_sleeptimer_get_timer_time_remaining</a> (<a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *handle, uint32_t *time)</td></tr>
<tr class="separator:ga6a06acb331e2e3c0efeb83f42a4d9c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf96ccea3e4d1727dc2fd2fa98f94ccb1" id="r_gaf96ccea3e4d1727dc2fd2fa98f94ccb1"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf96ccea3e4d1727dc2fd2fa98f94ccb1">sl_sleeptimer_get_remaining_time_of_first_timer</a> (uint16_t option_flags, uint32_t *time_remaining)</td></tr>
<tr class="separator:gaf96ccea3e4d1727dc2fd2fa98f94ccb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0397d420800b7c2d2afd5bbb9710067" id="r_gae0397d420800b7c2d2afd5bbb9710067"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae0397d420800b7c2d2afd5bbb9710067">sl_sleeptimer_get_tick_count</a> (void)</td></tr>
<tr class="separator:gae0397d420800b7c2d2afd5bbb9710067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf928eeb3dad0d43098b3aed9049959a" id="r_gaaf928eeb3dad0d43098b3aed9049959a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaf928eeb3dad0d43098b3aed9049959a">sl_sleeptimer_get_tick_count64</a> (void)</td></tr>
<tr class="separator:gaaf928eeb3dad0d43098b3aed9049959a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69085e47b9cc43ac0cfdc08783c13aed" id="r_ga69085e47b9cc43ac0cfdc08783c13aed"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga69085e47b9cc43ac0cfdc08783c13aed">sl_sleeptimer_get_timer_frequency</a> (void)</td></tr>
<tr class="separator:ga69085e47b9cc43ac0cfdc08783c13aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga157d43fdb64cb0d4afc864155bcf9bc8" id="r_ga157d43fdb64cb0d4afc864155bcf9bc8"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga157d43fdb64cb0d4afc864155bcf9bc8">sl_sleeptimer_convert_time_to_date</a> (<a class="el" href="#gaf41c2bc4240e5b819fc7f285f62172a2">sl_sleeptimer_timestamp_t</a> time, <a class="el" href="#ga27148a3d37b9f3728cbd18b56b4c9979">sl_sleeptimer_time_zone_offset_t</a> time_zone, <a class="el" href="#ga8b17c7e32e3ad35bb6b0a9c2001e8d64">sl_sleeptimer_date_t</a> *date)</td></tr>
<tr class="separator:ga157d43fdb64cb0d4afc864155bcf9bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc9658b94ee4e8f07912e6ad41ac0ad2" id="r_gadc9658b94ee4e8f07912e6ad41ac0ad2"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadc9658b94ee4e8f07912e6ad41ac0ad2">sl_sleeptimer_convert_time_to_date_64</a> (<a class="el" href="#ga5d4d9e5fe98012d2cffedb00caa9c91b">sl_sleeptimer_timestamp_64_t</a> time, <a class="el" href="#ga27148a3d37b9f3728cbd18b56b4c9979">sl_sleeptimer_time_zone_offset_t</a> time_zone, <a class="el" href="#ga8b17c7e32e3ad35bb6b0a9c2001e8d64">sl_sleeptimer_date_t</a> *date)</td></tr>
<tr class="separator:gadc9658b94ee4e8f07912e6ad41ac0ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3c762fbb3fed88f5f256d4c9a03fc67" id="r_gab3c762fbb3fed88f5f256d4c9a03fc67"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab3c762fbb3fed88f5f256d4c9a03fc67">sl_sleeptimer_convert_date_to_time</a> (<a class="el" href="#ga8b17c7e32e3ad35bb6b0a9c2001e8d64">sl_sleeptimer_date_t</a> *date, <a class="el" href="#gaf41c2bc4240e5b819fc7f285f62172a2">sl_sleeptimer_timestamp_t</a> *time)</td></tr>
<tr class="separator:gab3c762fbb3fed88f5f256d4c9a03fc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga600725ddd39a7ef36334f6eac0879001" id="r_ga600725ddd39a7ef36334f6eac0879001"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga600725ddd39a7ef36334f6eac0879001">sl_sleeptimer_convert_date_to_time_64</a> (<a class="el" href="#ga8b17c7e32e3ad35bb6b0a9c2001e8d64">sl_sleeptimer_date_t</a> *date, <a class="el" href="#ga5d4d9e5fe98012d2cffedb00caa9c91b">sl_sleeptimer_timestamp_64_t</a> *time)</td></tr>
<tr class="separator:ga600725ddd39a7ef36334f6eac0879001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28561cd8d4b4e31153d3dc02e68f2645" id="r_ga28561cd8d4b4e31153d3dc02e68f2645"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga28561cd8d4b4e31153d3dc02e68f2645">sl_sleeptimer_convert_date_to_str</a> (char *str, size_t size, const uint8_t *format, <a class="el" href="#ga8b17c7e32e3ad35bb6b0a9c2001e8d64">sl_sleeptimer_date_t</a> *date)</td></tr>
<tr class="separator:ga28561cd8d4b4e31153d3dc02e68f2645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd748d9a4654e9ae474a7020a5d9813" id="r_gafbd748d9a4654e9ae474a7020a5d9813"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafbd748d9a4654e9ae474a7020a5d9813">sl_sleeptimer_set_tz</a> (<a class="el" href="#ga27148a3d37b9f3728cbd18b56b4c9979">sl_sleeptimer_time_zone_offset_t</a> offset)</td></tr>
<tr class="separator:gafbd748d9a4654e9ae474a7020a5d9813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91ebac6960e114d933e1ef7c4f32294a" id="r_ga91ebac6960e114d933e1ef7c4f32294a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga27148a3d37b9f3728cbd18b56b4c9979">sl_sleeptimer_time_zone_offset_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga91ebac6960e114d933e1ef7c4f32294a">sl_sleeptimer_get_tz</a> (void)</td></tr>
<tr class="separator:ga91ebac6960e114d933e1ef7c4f32294a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d79ef7aa10606814bcc21053bfca558" id="r_ga4d79ef7aa10606814bcc21053bfca558"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#gaf41c2bc4240e5b819fc7f285f62172a2">sl_sleeptimer_timestamp_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4d79ef7aa10606814bcc21053bfca558">sl_sleeptimer_get_time</a> (void)</td></tr>
<tr class="separator:ga4d79ef7aa10606814bcc21053bfca558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e99647fc3da11223cf4e65b7ad8c52d" id="r_ga8e99647fc3da11223cf4e65b7ad8c52d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga5d4d9e5fe98012d2cffedb00caa9c91b">sl_sleeptimer_timestamp_64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8e99647fc3da11223cf4e65b7ad8c52d">sl_sleeptimer_get_time_64</a> (void)</td></tr>
<tr class="separator:ga8e99647fc3da11223cf4e65b7ad8c52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd64c7fbf7b0dfb7947a6f7bf288dca" id="r_gafbd64c7fbf7b0dfb7947a6f7bf288dca"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafbd64c7fbf7b0dfb7947a6f7bf288dca">sl_sleeptimer_set_time</a> (<a class="el" href="#gaf41c2bc4240e5b819fc7f285f62172a2">sl_sleeptimer_timestamp_t</a> time)</td></tr>
<tr class="separator:gafbd64c7fbf7b0dfb7947a6f7bf288dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63a00c3c2b137b68f66d47ae77f0d26b" id="r_ga63a00c3c2b137b68f66d47ae77f0d26b"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga63a00c3c2b137b68f66d47ae77f0d26b">sl_sleeptimer_set_time_64</a> (<a class="el" href="#ga5d4d9e5fe98012d2cffedb00caa9c91b">sl_sleeptimer_timestamp_64_t</a> time)</td></tr>
<tr class="separator:ga63a00c3c2b137b68f66d47ae77f0d26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2955c70feb8e0082ba54e30d2629d840" id="r_ga2955c70feb8e0082ba54e30d2629d840"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2955c70feb8e0082ba54e30d2629d840">sl_sleeptimer_get_datetime</a> (<a class="el" href="#ga8b17c7e32e3ad35bb6b0a9c2001e8d64">sl_sleeptimer_date_t</a> *date)</td></tr>
<tr class="separator:ga2955c70feb8e0082ba54e30d2629d840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga840c8ef8049b364a45899320a9f0c8bf" id="r_ga840c8ef8049b364a45899320a9f0c8bf"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga840c8ef8049b364a45899320a9f0c8bf">sl_sleeptimer_set_datetime</a> (<a class="el" href="#ga8b17c7e32e3ad35bb6b0a9c2001e8d64">sl_sleeptimer_date_t</a> *date)</td></tr>
<tr class="separator:ga840c8ef8049b364a45899320a9f0c8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga726d2e276fbac02b2246a446c3dcf755" id="r_ga726d2e276fbac02b2246a446c3dcf755"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga726d2e276fbac02b2246a446c3dcf755">sl_sleeptimer_build_datetime</a> (<a class="el" href="#ga8b17c7e32e3ad35bb6b0a9c2001e8d64">sl_sleeptimer_date_t</a> *date, uint16_t year, sl_sleeptimer_month_t month, uint8_t month_day, uint8_t hour, uint8_t min, uint8_t sec, <a class="el" href="#ga27148a3d37b9f3728cbd18b56b4c9979">sl_sleeptimer_time_zone_offset_t</a> tzOffset)</td></tr>
<tr class="separator:ga726d2e276fbac02b2246a446c3dcf755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7290544e59a3a9700a0dc4a808e014a3" id="r_ga7290544e59a3a9700a0dc4a808e014a3"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7290544e59a3a9700a0dc4a808e014a3">sl_sleeptimer_build_datetime_64</a> (<a class="el" href="#ga8b17c7e32e3ad35bb6b0a9c2001e8d64">sl_sleeptimer_date_t</a> *date, uint16_t year, sl_sleeptimer_month_t month, uint8_t month_day, uint8_t hour, uint8_t min, uint8_t sec, <a class="el" href="#ga27148a3d37b9f3728cbd18b56b4c9979">sl_sleeptimer_time_zone_offset_t</a> tzOffset)</td></tr>
<tr class="separator:ga7290544e59a3a9700a0dc4a808e014a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf63bbad4e29c0b655b3d210bf3b3b086" id="r_gaf63bbad4e29c0b655b3d210bf3b3b086"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf63bbad4e29c0b655b3d210bf3b3b086">sl_sleeptimer_convert_unix_time_to_ntp</a> (<a class="el" href="#gaf41c2bc4240e5b819fc7f285f62172a2">sl_sleeptimer_timestamp_t</a> time, uint32_t *ntp_time)</td></tr>
<tr class="separator:gaf63bbad4e29c0b655b3d210bf3b3b086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff086ed922350c8a4cffeed024d03871" id="r_gaff086ed922350c8a4cffeed024d03871"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaff086ed922350c8a4cffeed024d03871">sl_sleeptimer_convert_ntp_time_to_unix</a> (uint32_t ntp_time, <a class="el" href="#gaf41c2bc4240e5b819fc7f285f62172a2">sl_sleeptimer_timestamp_t</a> *time)</td></tr>
<tr class="separator:gaff086ed922350c8a4cffeed024d03871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa73b94e0c15a1e2cf6b3cb0b37120ed4" id="r_gaa73b94e0c15a1e2cf6b3cb0b37120ed4"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa73b94e0c15a1e2cf6b3cb0b37120ed4">sl_sleeptimer_convert_unix_time_to_zigbee</a> (<a class="el" href="#gaf41c2bc4240e5b819fc7f285f62172a2">sl_sleeptimer_timestamp_t</a> time, uint32_t *zigbee_time)</td></tr>
<tr class="separator:gaa73b94e0c15a1e2cf6b3cb0b37120ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab1267658b2ac5e4249e87412ce7dede" id="r_gaab1267658b2ac5e4249e87412ce7dede"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaab1267658b2ac5e4249e87412ce7dede">sl_sleeptimer_convert_zigbee_time_to_unix</a> (uint32_t zigbee_time, <a class="el" href="#gaf41c2bc4240e5b819fc7f285f62172a2">sl_sleeptimer_timestamp_t</a> *time)</td></tr>
<tr class="separator:gaab1267658b2ac5e4249e87412ce7dede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga173dc0338a7c53c13c73a4859158b901" id="r_ga173dc0338a7c53c13c73a4859158b901"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="#ga27148a3d37b9f3728cbd18b56b4c9979">sl_sleeptimer_time_zone_offset_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga173dc0338a7c53c13c73a4859158b901">sl_sleeptimer_set_tz_ahead_utc</a> (uint8_t hours, uint8_t minutes)</td></tr>
<tr class="separator:ga173dc0338a7c53c13c73a4859158b901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd73a4283a8c257f8e9c74f410679073" id="r_gafd73a4283a8c257f8e9c74f410679073"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="#ga27148a3d37b9f3728cbd18b56b4c9979">sl_sleeptimer_time_zone_offset_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafd73a4283a8c257f8e9c74f410679073">sl_sleeptimer_set_tz_behind_utc</a> (uint8_t hours, uint8_t minutes)</td></tr>
<tr class="separator:gafd73a4283a8c257f8e9c74f410679073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d7c4ae596755e3e5e3c0c0aa5e749b3" id="r_ga7d7c4ae596755e3e5e3c0c0aa5e749b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7d7c4ae596755e3e5e3c0c0aa5e749b3">sl_sleeptimer_delay_millisecond</a> (uint16_t time_ms)</td></tr>
<tr class="separator:ga7d7c4ae596755e3e5e3c0c0aa5e749b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf3a3eb05b0f5adbc7ee488113299f61" id="r_gadf3a3eb05b0f5adbc7ee488113299f61"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadf3a3eb05b0f5adbc7ee488113299f61">sl_sleeptimer_ms_to_tick</a> (uint16_t time_ms)</td></tr>
<tr class="separator:gadf3a3eb05b0f5adbc7ee488113299f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7484d4be4877b94a687f4410fccc6271" id="r_ga7484d4be4877b94a687f4410fccc6271"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7484d4be4877b94a687f4410fccc6271">sl_sleeptimer_ms32_to_tick</a> (uint32_t time_ms, uint32_t *tick)</td></tr>
<tr class="separator:ga7484d4be4877b94a687f4410fccc6271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3218039eab8d09231cc092fdc2a1dba5" id="r_ga3218039eab8d09231cc092fdc2a1dba5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3218039eab8d09231cc092fdc2a1dba5">sl_sleeptimer_get_max_ms32_conversion</a> (void)</td></tr>
<tr class="separator:ga3218039eab8d09231cc092fdc2a1dba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c2a2a131e401894d3e09513442667b5" id="r_ga2c2a2a131e401894d3e09513442667b5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2c2a2a131e401894d3e09513442667b5">sl_sleeptimer_tick_to_ms</a> (uint32_t tick)</td></tr>
<tr class="separator:ga2c2a2a131e401894d3e09513442667b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6882d0577137d8e20ec531be45678fba" id="r_ga6882d0577137d8e20ec531be45678fba"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6882d0577137d8e20ec531be45678fba">sl_sleeptimer_tick64_to_ms</a> (uint64_t tick, uint64_t *ms)</td></tr>
<tr class="separator:ga6882d0577137d8e20ec531be45678fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b38592836a9a01d6f315d417d3d6cd9" id="r_ga0b38592836a9a01d6f315d417d3d6cd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0b38592836a9a01d6f315d417d3d6cd9">sl_sleeptimer_is_power_manager_early_restore_timer_latest_to_expire</a> (void)</td></tr>
<tr class="separator:ga0b38592836a9a01d6f315d417d3d6cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcb95c35f7307d91df1818e71f6540d2" id="r_gadcb95c35f7307d91df1818e71f6540d2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadcb95c35f7307d91df1818e71f6540d2">sl_sleeptimer_start_timer_ms</a> (<a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *handle, uint32_t timeout_ms, <a class="el" href="#ga9049589e4153204fb3e97cbe1ecda89b">sl_sleeptimer_timer_callback_t</a> callback, void *callback_data, uint8_t priority, uint16_t option_flags)</td></tr>
<tr class="separator:gadcb95c35f7307d91df1818e71f6540d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3da1641c9bae0857ba3cffcbc41f21a" id="r_gab3da1641c9bae0857ba3cffcbc41f21a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab3da1641c9bae0857ba3cffcbc41f21a">sl_sleeptimer_restart_timer_ms</a> (<a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *handle, uint32_t timeout_ms, <a class="el" href="#ga9049589e4153204fb3e97cbe1ecda89b">sl_sleeptimer_timer_callback_t</a> callback, void *callback_data, uint8_t priority, uint16_t option_flags)</td></tr>
<tr class="separator:gab3da1641c9bae0857ba3cffcbc41f21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4639653b4bf4ed68049b2a12a6c6d83" id="r_gae4639653b4bf4ed68049b2a12a6c6d83"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae4639653b4bf4ed68049b2a12a6c6d83">sl_sleeptimer_start_periodic_timer_ms</a> (<a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *handle, uint32_t timeout_ms, <a class="el" href="#ga9049589e4153204fb3e97cbe1ecda89b">sl_sleeptimer_timer_callback_t</a> callback, void *callback_data, uint8_t priority, uint16_t option_flags)</td></tr>
<tr class="separator:gae4639653b4bf4ed68049b2a12a6c6d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a44174e7a8eccbabde499875cb8462a" id="r_ga1a44174e7a8eccbabde499875cb8462a"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1a44174e7a8eccbabde499875cb8462a">sl_sleeptimer_restart_periodic_timer_ms</a> (<a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *handle, uint32_t timeout_ms, <a class="el" href="#ga9049589e4153204fb3e97cbe1ecda89b">sl_sleeptimer_timer_callback_t</a> callback, void *callback_data, uint8_t priority, uint16_t option_flags)</td></tr>
<tr class="separator:ga1a44174e7a8eccbabde499875cb8462a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c13ce5d0c1fc60a1596201932bb6b5f" id="r_ga4c13ce5d0c1fc60a1596201932bb6b5f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4c13ce5d0c1fc60a1596201932bb6b5f">sl_sleeptimer_get_clock_accuracy</a> (void)</td></tr>
<tr class="memdesc:ga4c13ce5d0c1fc60a1596201932bb6b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the precision (in PPM) of the sleeptimer's clock.  <br /></td></tr>
<tr class="separator:ga4c13ce5d0c1fc60a1596201932bb6b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Sleep Timer can be used for creating timers which are tightly integrated with power management. The Power Manager requires precision timing to have all clocks ready on time, so that wakeup happens a little bit earlier to prepare the system to be ready at the right time. Sleep Timer uses one Hardware Timer and creates multiple software timer instances. It is important to note that when sleeptimer is used with WTIMER/TIMER, the MCU cannot go to EM2 energy mode because WTIMER/TIMER uses a high frequency clock source which is not retained in low energy mode.</p>
<p>The sleeptimer.c and sleeptimer.h source files for the SLEEPTIMER device driver library are in the service/sleeptimer folder.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="sleeptimer_intro"></a>
Introduction</h1>
<p>The Sleeptimer driver provides software timers, delays, timekeeping and date functionalities using a low-frequency real-time clock peripheral.</p>
<p>All Silicon Labs microcontrollers equipped with the RTC or RTCC peripheral are currently supported. Only one instance of this driver can be initialized by the application.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="sleeptimer_functionalities_overview"></a>
Functionalities overview</h1>
<p><br  />
 </p>
<h2><a class="anchor" id="software_timers"></a>
Software Timers</h2>
<p>This functionality allows the user to create periodic and one shot timers. A user callback can be associated with a timer and is called when the timer expires.</p>
<p>Timer structures must be allocated by the user. The function is called from within an interrupt handler with interrupts enabled.</p>
<p><br  />
 </p>
<h2><a class="anchor" id="timekeeping"></a>
Timekeeping</h2>
<p>A 64-bits tick counter is accessible through the </p><ul>
<li>uint64_t <a class="el" href="#gaaf928eeb3dad0d43098b3aed9049959a">sl_sleeptimer_get_tick_count64(void)</a> API. It keeps the tick count since the initialization of the driver</li>
</ul>
<p>The <code>SL_SLEEPTIMER_WALLCLOCK_CONFIG</code> configuration enables a UNIX timestamp (seconds count since January 1, 1970, 00:00:00).</p>
<p>This timestamp can be retrieved/modified using the following API:</p>
<ul>
<li>sl_sleeptimer_timestamp_t <a class="el" href="#ga4d79ef7aa10606814bcc21053bfca558">sl_sleeptimer_get_time(void)</a>; </li>
<li>sl_status_t <a class="el" href="#gafbd64c7fbf7b0dfb7947a6f7bf288dca">sl_sleeptimer_set_time(sl_sleeptimer_timestamp_t time)</a>;</li>
</ul>
<p>Convenience conversion functions are provided to convert UNIX timestamp to/from NTP and Zigbee cluster format :</p>
<ul>
<li>sl_status_t <a class="el" href="#gaf63bbad4e29c0b655b3d210bf3b3b086">sl_sleeptimer_convert_unix_time_to_ntp(sl_sleeptimer_timestamp_t time, uint32_t *ntp_time)</a>; </li>
<li>sl_status_t <a class="el" href="#gaff086ed922350c8a4cffeed024d03871">sl_sleeptimer_convert_ntp_time_to_unix(uint32_t ntp_time, sl_sleeptimer_timestamp_t *time)</a>; </li>
<li>sl_status_t <a class="el" href="#gaa73b94e0c15a1e2cf6b3cb0b37120ed4">sl_sleeptimer_convert_unix_time_to_zigbee(sl_sleeptimer_timestamp_t time, uint32_t *zigbee_time)</a>; </li>
<li>sl_status_t <a class="el" href="#gaab1267658b2ac5e4249e87412ce7dede">sl_sleeptimer_convert_zigbee_time_to_unix(uint32_t zigbee_time, sl_sleeptimer_timestamp_t *time)</a>;</li>
</ul>
<p><br  />
 </p>
<h2><a class="anchor" id="date"></a>
Date</h2>
<p>The previously described internal timestamp can also be retrieved/modified in a date format sl_sleeptimer_date_t.</p>
<p><br  />
 <b>API :</b> <br  />
 </p><ul>
<li>sl_status_t <a class="el" href="#ga2955c70feb8e0082ba54e30d2629d840">sl_sleeptimer_get_datetime(sl_sleeptimer_date_t *date)</a>; </li>
<li>sl_status_t <a class="el" href="#ga840c8ef8049b364a45899320a9f0c8bf">sl_sleeptimer_set_datetime(sl_sleeptimer_date_t *date)</a>;</li>
</ul>
<p><br  />
 </p>
<h2><a class="anchor" id="frequency_setup"></a>
Frequency Setup and Tick Count</h2>
<p>This driver works with a configurable time unit called tick.</p>
<p>The frequency of the ticks is based on the clock source and the internal frequency divider.</p>
<p>WTIMER/TIMER peripherals uses high frequency oscillator. To have a reasonable tick frequency, divider is set to maximum value (1024).</p>
<p>One of the following clock sources must be enabled before initializing the sleeptimer:</p>
<ul>
<li>LFXO: external crystal oscillator. Typically running at 32.768 kHz. </li>
<li>LFRCO: internal oscillator running at 32.768 kHz </li>
<li>ULFRCO: Ultra low-frequency oscillator running at 1.000 kHz </li>
<li>HFXO: High Frequency Crystal Oscillator at 39 Mhz. HFXO is only needed when Sleeptimer runs on TIMER or WTIMER.</li>
</ul>
<p>The frequency divider is selected with the <code>SL_SLEEPTIMER_FREQ_DIVIDER</code> configuration. Its value must be a power of two within the range of 1 to 32. The number of ticks per second (sleeptimer frequency) is dictated by the following formula:</p>
<p>Tick (seconds) = 1 / (clock_frequency / frequency_divider)</p>
<p>The highest resolution for a tick is 30.5 us. It is achieved with a 32.768 kHz clock and a divider of 1.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="sleeptimer_getting_started"></a>
Getting Started</h1>
<p><br  />
 </p>
<h2><a class="anchor" id="clock_selection"></a>
Clock Selection</h2>
<p>The sleeptimer relies on the hardware timer to operate. The hardware timer peripheral must be properly clocked from the application. Selecting the appropriate timer is crucial for design considerations. Each timer can potentially be used as a sleeptimer and is also available to the user. However, note that if a timer is used by the sleeptimer, it can't be used by the application and vice versa.</p>
<p>For WTIMER/TIMER peripherals, the user must select the appropriate oscillator if it is not the default wanted clock source.</p>
<p>When WTIMER/TIMER is selected, sleeptimer uses channel 0 and it is not possible to use other channels of the same instance for other purposes.</p>
<p><br  />
 </p>
<h2><a class="anchor" id="Clock"></a>
Selection in a Project without Micrium OS</h2>
<p>When RTC, RTCC, or BURTC is selected, the clock source for the peripheral must be configured and enabled in the application before initializing the sleeptimer module or any communication stacks. Most of the time, it consists in enabling the desired oscillators and setting up the clock source for the peripheral, like in the following example:</p>
<div class="fragment"><div class="line">CMU_ClockSelectSet(cmuClock_LFE, cmuSelect_LFRCO);</div>
<div class="line">CMU_ClockEnable(cmuClock_RTCC, <span class="keyword">true</span>);</div>
</div><!-- fragment --><p><br  />
 </p>
<h2><a class="anchor" id="clock_branch_select"></a>
Clock Branch Select</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Clock   </th><th class="markdownTableHeadNone">Enum   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Frequency    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">LFXO   </td><td class="markdownTableBodyNone"><b>cmuSelect_LFXO</b>   </td><td class="markdownTableBodyNone">Low-frequency crystal oscillator   </td><td class="markdownTableBodyNone">32.768 Khz    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">LFRCO   </td><td class="markdownTableBodyNone"><b>cmuSelect_LFRCO</b>   </td><td class="markdownTableBodyNone">Low-frequency RC oscillator   </td><td class="markdownTableBodyNone">32.768 Khz    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ULFRCO   </td><td class="markdownTableBodyNone"><b>cmuSelect_ULFRCO</b>   </td><td class="markdownTableBodyNone">Ultra low-frequency RC oscillator   </td><td class="markdownTableBodyNone">1 Khz   </td></tr>
</table>
<p><br  />
 </p>
<h2><a class="anchor" id="timer_clock_enable"></a>
Timer Clock Enable</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Module   </th><th class="markdownTableHeadNone">Enum   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">RTCC   </td><td class="markdownTableBodyNone"><b>cmuClock_RTCC</b>   </td><td class="markdownTableBodyNone">Real-time counter and calendar clock (LF E branch)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">RTC   </td><td class="markdownTableBodyNone"><b>cmuClock_RTC</b>   </td><td class="markdownTableBodyNone">Real time counter clock (LF A branch)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">BURTC   </td><td class="markdownTableBodyNone"><b>cmuClock_BURTC</b>   </td><td class="markdownTableBodyNone">BURTC clock (EM4 Group A branch)   </td></tr>
</table>
<p>When the Radio internal RTC (PRORTC) is selected, it is not necessary to configure the clock source for the peripheral. However, it is important to enable the desired oscillator before initializing the sleeptimer module or any communication stacks. The best oscillator available (LFXO being the first choice) will be used by the sleeptimer at initalization. The following example shows how the desired oscilator should be enabled:</p>
<div class="fragment"><div class="line">CMU_OscillatorEnable(cmuSelect_LFXO, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
</div><!-- fragment --><p><br  />
 </p>
<h2><a class="anchor" id="clock_micrium_os"></a>
Clock Selection in a Project with Micrium OS</h2>
<p>When Micrium OS is used, a BSP (all instances) is provided that sets up some parts of the clock tree. The sleeptimer clock source will be enabled by this bsp. However, the desired oscillator remains configurable from the file <b>bsp_cfg.h</b>.</p>
<p>The configuration <code>BSP_LF_CLK_SEL</code> determines which oscillator will be used by the sleeptimer's hardware timer peripheral. It can take the following values:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Config   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Frequency    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>BSP_LF_CLK_LFXO</b>   </td><td class="markdownTableBodyNone">Low-frequency crystal oscillator   </td><td class="markdownTableBodyNone">32.768 Khz    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>BSP_LF_CLK_LFRCO</b>   </td><td class="markdownTableBodyNone">Low-frequency RC oscillator   </td><td class="markdownTableBodyNone">32.768 Khz    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>BSP_LF_CLK_ULFRCO</b>   </td><td class="markdownTableBodyNone">Ultra low-frequency RC oscillator   </td><td class="markdownTableBodyNone">1 Khz   </td></tr>
</table>
<p><br  />
 </p>
<h1><a class="anchor" id="sleeptimer_conf"></a>
Configuration Options</h1>
<p><code>SL_SLEEPTIMER_PERIPHERAL</code> can be set to one of the following values:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Config   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>SL_SLEEPTIMER_PERIPHERAL_DEFAULT</code>   </td><td class="markdownTableBodyNone">Selects either RTC or RTCC, depending of what is available on the platform.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>SL_SLEEPTIMER_PERIPHERAL_RTCC</code>   </td><td class="markdownTableBodyNone">Selects RTCC    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>SL_SLEEPTIMER_PERIPHERAL_RTC</code>   </td><td class="markdownTableBodyNone">Selects RTC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>SL_SLEEPTIMER_PERIPHERAL_PRORTC</code>   </td><td class="markdownTableBodyNone">Selects Internal radio RTC. Available only on EFR32XG13, EFR32XG14, EFR32XG21 and EFR32XG22 families.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>SL_SLEEPTIMER_PERIPHERAL_BURTC</code>   </td><td class="markdownTableBodyNone">Selects BURTC. Not available on Series 0 devices.   </td></tr>
</table>
<p><code>SL_SLEEPTIMER_WALLCLOCK_CONFIG</code> must be set to 1 to enable timestamp and date functionnalities.</p>
<p><code>SL_SLEEPTIMER_FREQ_DIVIDER</code> must be a power of 2 within the range 1 to 32. When <code>SL_SLEEPTIMER_PERIPHERAL</code> is set to <code>SL_SLEEPTIMER_PERIPHERAL_PRORTC</code>, <code>SL_SLEEPTIMER_FREQ_DIVIDER</code> must be set to 1.</p>
<p><code>SL_SLEEPTIMER_PRORTC_HAL_OWNS_IRQ_HANDLER</code> is only meaningful when <code>SL_SLEEPTIMER_PERIPHERAL</code> is set to <code>SL_SLEEPTIMER_PERIPHERAL_PRORTC</code>. Set to 1 if no communication stack is used in your project. Otherwise, must be set to 0.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="sleeptimer_api"></a>
The API</h1>
<p>This section contains brief descriptions of the API functions. For more information about input and output parameters and return values, click on the hyperlinked function names. Most functions return an error code, <code>SL_STATUS_OK</code> is returned on success, see <a class="el" href="sl__status_8h_source.html">sl_status.h</a> for other error codes.</p>
<p>The application code must include the <em><a class="el" href="sl__sleeptimer_8h.html" title="SLEEPTIMER API definition.">sl_sleeptimer.h</a></em> header file.</p>
<p>All API functions can be called from within interrupt handlers.</p>
<p><a class="el" href="#gae661a78719a6acc014efa15216ae4a54">sl_sleeptimer_init()</a> <br  />
 These functions initialize the sleeptimer driver. Typically, <a class="el" href="#gae661a78719a6acc014efa15216ae4a54">sl_sleeptimer_init()</a> is called once in the startup code.</p>
<p><a class="el" href="#ga43c32bdb2a9fcfbe279563a9fd689711">sl_sleeptimer_start_timer()</a> <br  />
 Start a one shot 32 bits timer. When a timer expires, a user-supplied callback function is called. A pointer to this function is passed to <a class="el" href="#ga43c32bdb2a9fcfbe279563a9fd689711">sl_sleeptimer_start_timer()</a>. See <a class="el" href="#callback">callback</a> for details of the callback prototype.</p>
<p><a class="el" href="#gaacd5a666731a0ba4823107e552e23e69">sl_sleeptimer_restart_timer()</a> <br  />
 Restart a one shot 32 bits timer. When a timer expires, a user-supplied callback function is called. A pointer to this function is passed to <a class="el" href="#ga43c32bdb2a9fcfbe279563a9fd689711">sl_sleeptimer_start_timer()</a>. See <a class="el" href="#callback">callback</a> for details of the callback prototype.</p>
<p><a class="el" href="#ga2ceb1b76334902525dd32e937e90bb16">sl_sleeptimer_start_periodic_timer()</a> <br  />
 Start a periodic 32 bits timer. When a timer expires, a user-supplied callback function is called. A pointer to this function is passed to <a class="el" href="#ga43c32bdb2a9fcfbe279563a9fd689711">sl_sleeptimer_start_timer()</a>. See <a class="el" href="#callback">callback</a> for details of the callback prototype.</p>
<p><a class="el" href="#gaf54408a7f172b684de33d9a7f4e01be9">sl_sleeptimer_restart_periodic_timer()</a> <br  />
 Restart a periodic 32 bits timer. When a timer expires, a user-supplied callback function is called. A pointer to this function is passed to <a class="el" href="#ga43c32bdb2a9fcfbe279563a9fd689711">sl_sleeptimer_start_timer()</a>. See <a class="el" href="#callback">callback</a> for details of the callback prototype.</p>
<p><a class="el" href="#ga1f4f25aa754cd35214dba9762450b0ca">sl_sleeptimer_stop_timer()</a> <br  />
 Stop a timer.</p>
<p><a class="el" href="#ga6a06acb331e2e3c0efeb83f42a4d9c16">sl_sleeptimer_get_timer_time_remaining()</a> <br  />
 Get the time remaining before the timer expires.</p>
<p><a class="el" href="#ga7d7c4ae596755e3e5e3c0c0aa5e749b3">sl_sleeptimer_delay_millisecond()</a> <br  />
 Delay for the given number of milliseconds. This is an "active wait" delay function.</p>
<p><a class="el" href="#gac0236c1c353317c41d577867e7429874">sl_sleeptimer_is_timer_running()</a> <br  />
 Check if a timer is running.</p>
<p><a class="el" href="#ga4d79ef7aa10606814bcc21053bfca558">sl_sleeptimer_get_time()</a>, <a class="el" href="#gafbd64c7fbf7b0dfb7947a6f7bf288dca">sl_sleeptimer_set_time()</a> <br  />
 Get or set wallclock time.</p>
<p><a class="el" href="#gadf3a3eb05b0f5adbc7ee488113299f61">sl_sleeptimer_ms_to_tick()</a>, <a class="el" href="#ga7484d4be4877b94a687f4410fccc6271">sl_sleeptimer_ms32_to_tick()</a>, <a class="el" href="#ga2c2a2a131e401894d3e09513442667b5">sl_sleeptimer_tick_to_ms()</a>, <a class="el" href="#ga6882d0577137d8e20ec531be45678fba">sl_sleeptimer_tick64_to_ms()</a> <br  />
 Convert between milliseconds and RTC/RTCC counter ticks.</p>
<p><br  />
 <a class="anchor" id="callback"></a><b>The timer expiry callback function:</b> <br  />
 The callback function, prototyped as <a class="el" href="#ga9049589e4153204fb3e97cbe1ecda89b">sl_sleeptimer_timer_callback_t()</a>, is called from within the RTC peripheral interrupt handler on timer expiration. <a class="el" href="#ga9049589e4153204fb3e97cbe1ecda89b">sl_sleeptimer_timer_callback_t(sl_sleeptimer_timer_handle_t *handle, void *data)</a></p>
<p><br  />
 </p>
<h1><a class="anchor" id="sleeptimer_example"></a>
Example</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="sl__sleeptimer_8h.html">sl_sleeptimer.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> my_timer_callback(<a class="code hl_struct" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *handle, <span class="keywordtype">void</span> *data)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">//Code executed when the timer expire.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> start_timer(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  sl_status_t status;</div>
<div class="line">  <a class="code hl_struct" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> my_timer;</div>
<div class="line">  uint32_t timer_timeout = 300;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// We assume the sleeptimer is initialized properly</span></div>
<div class="line"> </div>
<div class="line">  status = <a class="code hl_function" href="#ga43c32bdb2a9fcfbe279563a9fd689711">sl_sleeptimer_start_timer</a>(&amp;my_timer,</div>
<div class="line">                                     timer_timeout,</div>
<div class="line">                                     my_timer_callback,</div>
<div class="line">                                     (<span class="keywordtype">void</span> *)NULL,</div>
<div class="line">                                     0,</div>
<div class="line">                                     0);</div>
<div class="line">  <span class="keywordflow">if</span>(status != SL_STATUS_OK) {</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__sleeptimer_html_ga43c32bdb2a9fcfbe279563a9fd689711"><div class="ttname"><a href="#ga43c32bdb2a9fcfbe279563a9fd689711">sl_sleeptimer_start_timer</a></div><div class="ttdeci">sl_status_t sl_sleeptimer_start_timer(sl_sleeptimer_timer_handle_t *handle, uint32_t timeout, sl_sleeptimer_timer_callback_t callback, void *callback_data, uint8_t priority, uint16_t option_flags)</div><div class="ttdef"><b>Definition</b> sl_sleeptimer.c:210</div></div>
<div class="ttc" id="asl__sleeptimer_8h_html"><div class="ttname"><a href="sl__sleeptimer_8h.html">sl_sleeptimer.h</a></div><div class="ttdoc">SLEEPTIMER API definition.</div></div>
<div class="ttc" id="astructsl__sleeptimer__timer__handle_html"><div class="ttname"><a href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle</a></div><div class="ttdoc">Timer structure for sleeptimer.</div><div class="ttdef"><b>Definition</b> sl_sleeptimer.h:76</div></div>
</div><!-- fragment --> <h2 class="groupheader">Typedef Documentation</h2>
<a id="ga9049589e4153204fb3e97cbe1ecda89b" name="ga9049589e4153204fb3e97cbe1ecda89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9049589e4153204fb3e97cbe1ecda89b">&#9670;&#160;</a></span>sl_sleeptimer_timer_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* sl_sleeptimer_timer_callback_t) (<a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *handle, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef for the user supplied callback function which is called when a timer expires.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The timer handle.</td></tr>
    <tr><td class="paramname">data</td><td>An extra parameter for the user application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga726d2e276fbac02b2246a446c3dcf755" name="ga726d2e276fbac02b2246a446c3dcf755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga726d2e276fbac02b2246a446c3dcf755">&#9670;&#160;</a></span>sl_sleeptimer_build_datetime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_build_datetime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga8b17c7e32e3ad35bb6b0a9c2001e8d64">sl_sleeptimer_date_t</a> *</td>          <td class="paramname"><span class="paramname"><em>date</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>year</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl_sleeptimer_month_t</td>          <td class="paramname"><span class="paramname"><em>month</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>month_day</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>hour</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>sec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga27148a3d37b9f3728cbd18b56b4c9979">sl_sleeptimer_time_zone_offset_t</a></td>          <td class="paramname"><span class="paramname"><em>tzOffset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds a date time structure based on the provided parameters, where the maximum supported date is 10:14:07 PM 01/18/2038.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date</td><td>Pointer to the structure to be populated. </td></tr>
    <tr><td class="paramname">year</td><td>Current year. May be provided based on a 0 Epoch or a 1900 Epoch. </td></tr>
    <tr><td class="paramname">month</td><td>Months since January. Expected value: 0-11. </td></tr>
    <tr><td class="paramname">month_day</td><td>Day of the month. Expected value: 1-31. </td></tr>
    <tr><td class="paramname">hour</td><td>Hours since midnight. Expected value: 0-23. </td></tr>
    <tr><td class="paramname">min</td><td>Minutes after the hour. Expected value: 0-59. </td></tr>
    <tr><td class="paramname">sec</td><td>Seconds after the minute. Expected value: 0-59. </td></tr>
    <tr><td class="paramname">tzOffset</td><td>Offset, in seconds, from UTC.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Function definition is accessible only when SL_SLEEPTIMER_WALLCLOCK_CONFIG is set to 1.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="ga7290544e59a3a9700a0dc4a808e014a3" name="ga7290544e59a3a9700a0dc4a808e014a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7290544e59a3a9700a0dc4a808e014a3">&#9670;&#160;</a></span>sl_sleeptimer_build_datetime_64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_build_datetime_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga8b17c7e32e3ad35bb6b0a9c2001e8d64">sl_sleeptimer_date_t</a> *</td>          <td class="paramname"><span class="paramname"><em>date</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>year</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl_sleeptimer_month_t</td>          <td class="paramname"><span class="paramname"><em>month</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>month_day</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>hour</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>sec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga27148a3d37b9f3728cbd18b56b4c9979">sl_sleeptimer_time_zone_offset_t</a></td>          <td class="paramname"><span class="paramname"><em>tzOffset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds a date time structure based on the provided parameters, where the maximum supported date is 11:59:59 PM 12/31/11899.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date</td><td>Pointer to the structure to be populated. </td></tr>
    <tr><td class="paramname">year</td><td>Current year based on 0 Epoch. </td></tr>
    <tr><td class="paramname">month</td><td>Months since January. Expected value: 0-11. </td></tr>
    <tr><td class="paramname">month_day</td><td>Day of the month. Expected value: 1-31. </td></tr>
    <tr><td class="paramname">hour</td><td>Hours since midnight. Expected value: 0-23. </td></tr>
    <tr><td class="paramname">min</td><td>Minutes after the hour. Expected value: 0-59. </td></tr>
    <tr><td class="paramname">sec</td><td>Seconds after the minute. Expected value: 0-59. </td></tr>
    <tr><td class="paramname">tzOffset</td><td>Offset, in seconds, from UTC.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Resulting date structure's year will be based on 1900 epoch</dd>
<dd>
Function definition is accessible only when SL_SLEEPTIMER_WALLCLOCK_CONFIG is set to 1.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="ga28561cd8d4b4e31153d3dc02e68f2645" name="ga28561cd8d4b4e31153d3dc02e68f2645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28561cd8d4b4e31153d3dc02e68f2645">&#9670;&#160;</a></span>sl_sleeptimer_convert_date_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sl_sleeptimer_convert_date_to_str </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga8b17c7e32e3ad35bb6b0a9c2001e8d64">sl_sleeptimer_date_t</a> *</td>          <td class="paramname"><span class="paramname"><em>date</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert date to string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Output string. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the input array. </td></tr>
    <tr><td class="paramname">format</td><td>The format specification character. </td></tr>
    <tr><td class="paramname">date</td><td>Pointer to date structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if error. Number of character in the output string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Refer strftime() from UNIX. <a href="http://man7.org/linux/man-pages/man3/strftime.3.html">http://man7.org/linux/man-pages/man3/strftime.3.html</a></dd>
<dd>
Function definition is accessible only when SL_SLEEPTIMER_WALLCLOCK_CONFIG is set to 1. </dd></dl>

</div>
</div>
<a id="gab3c762fbb3fed88f5f256d4c9a03fc67" name="gab3c762fbb3fed88f5f256d4c9a03fc67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3c762fbb3fed88f5f256d4c9a03fc67">&#9670;&#160;</a></span>sl_sleeptimer_convert_date_to_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_convert_date_to_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga8b17c7e32e3ad35bb6b0a9c2001e8d64">sl_sleeptimer_date_t</a> *</td>          <td class="paramname"><span class="paramname"><em>date</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaf41c2bc4240e5b819fc7f285f62172a2">sl_sleeptimer_timestamp_t</a> *</td>          <td class="paramname"><span class="paramname"><em>time</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a date into a Unix timestamp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date</td><td>Pointer to date to convert. </td></tr>
    <tr><td class="paramname">time</td><td>Pointer to converted 32 bit Unix timestamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Dates are based on the Unix time representation. Range of dates supported :<ul>
<li>January 1, 1970, 00:00:00 to January 19, 2038, 03:14:00</li>
</ul>
</dd>
<dd>
Function definition is accessible only when SL_SLEEPTIMER_WALLCLOCK_CONFIG is set to 1. </dd></dl>

</div>
</div>
<a id="ga600725ddd39a7ef36334f6eac0879001" name="ga600725ddd39a7ef36334f6eac0879001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga600725ddd39a7ef36334f6eac0879001">&#9670;&#160;</a></span>sl_sleeptimer_convert_date_to_time_64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_convert_date_to_time_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga8b17c7e32e3ad35bb6b0a9c2001e8d64">sl_sleeptimer_date_t</a> *</td>          <td class="paramname"><span class="paramname"><em>date</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga5d4d9e5fe98012d2cffedb00caa9c91b">sl_sleeptimer_timestamp_64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>time</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a date into a 64 bit timestamp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date</td><td>Pointer to date to convert. </td></tr>
    <tr><td class="paramname">time</td><td>Pointer to converted 64 bit Unix timestamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Dates are based on the 64 bit Unix time representation. Range of dates supported :<ul>
<li>January 1, 1900, 00:00:00 to December 31, 11899 23:59:59.</li>
</ul>
</dd>
<dd>
Function definition is accessible only when SL_SLEEPTIMER_WALLCLOCK_CONFIG is set to 1. </dd></dl>

</div>
</div>
<a id="gaff086ed922350c8a4cffeed024d03871" name="gaff086ed922350c8a4cffeed024d03871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff086ed922350c8a4cffeed024d03871">&#9670;&#160;</a></span>sl_sleeptimer_convert_ntp_time_to_unix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_convert_ntp_time_to_unix </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>ntp_time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaf41c2bc4240e5b819fc7f285f62172a2">sl_sleeptimer_timestamp_t</a> *</td>          <td class="paramname"><span class="paramname"><em>time</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts NTP timestamp into Unix timestamp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ntp_time</td><td>NTP Timestamp. </td></tr>
    <tr><td class="paramname">time</td><td>Pointer to Unix timestamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>NTP timestamp range supported : 0x83AA 7E80 to 0xFFFF FFFF ie. January 1, 1970, 00:00:00 to February 07, 2036, 06:28:15</dd>
<dd>
Function definition is accessible only when SL_SLEEPTIMER_WALLCLOCK_CONFIG is set to 1.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="ga157d43fdb64cb0d4afc864155bcf9bc8" name="ga157d43fdb64cb0d4afc864155bcf9bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga157d43fdb64cb0d4afc864155bcf9bc8">&#9670;&#160;</a></span>sl_sleeptimer_convert_time_to_date()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_convert_time_to_date </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gaf41c2bc4240e5b819fc7f285f62172a2">sl_sleeptimer_timestamp_t</a></td>          <td class="paramname"><span class="paramname"><em>time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga27148a3d37b9f3728cbd18b56b4c9979">sl_sleeptimer_time_zone_offset_t</a></td>          <td class="paramname"><span class="paramname"><em>time_zone</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga8b17c7e32e3ad35bb6b0a9c2001e8d64">sl_sleeptimer_date_t</a> *</td>          <td class="paramname"><span class="paramname"><em>date</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a Unix timestamp into a date.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>32 bit Unix timestamp to convert. </td></tr>
    <tr><td class="paramname">time_zone</td><td>Offset from UTC in second. </td></tr>
    <tr><td class="paramname">date</td><td>Pointer to converted date.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Time is in Standard Time.</dd>
<dd>
Function definition is accessible only when SL_SLEEPTIMER_WALLCLOCK_CONFIG is set to 1.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="gadc9658b94ee4e8f07912e6ad41ac0ad2" name="gadc9658b94ee4e8f07912e6ad41ac0ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc9658b94ee4e8f07912e6ad41ac0ad2">&#9670;&#160;</a></span>sl_sleeptimer_convert_time_to_date_64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_convert_time_to_date_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga5d4d9e5fe98012d2cffedb00caa9c91b">sl_sleeptimer_timestamp_64_t</a></td>          <td class="paramname"><span class="paramname"><em>time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga27148a3d37b9f3728cbd18b56b4c9979">sl_sleeptimer_time_zone_offset_t</a></td>          <td class="paramname"><span class="paramname"><em>time_zone</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga8b17c7e32e3ad35bb6b0a9c2001e8d64">sl_sleeptimer_date_t</a> *</td>          <td class="paramname"><span class="paramname"><em>date</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a 64 bit Unix timestamp into a date.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>64 bit Unix timestamp to convert. </td></tr>
    <tr><td class="paramname">time_zone</td><td>Offset from UTC in second. </td></tr>
    <tr><td class="paramname">date</td><td>Pointer to converted date.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Time is in Standard Time.</dd>
<dd>
Function definition is accessible only when SL_SLEEPTIMER_WALLCLOCK_CONFIG is set to 1.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="gaf63bbad4e29c0b655b3d210bf3b3b086" name="gaf63bbad4e29c0b655b3d210bf3b3b086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf63bbad4e29c0b655b3d210bf3b3b086">&#9670;&#160;</a></span>sl_sleeptimer_convert_unix_time_to_ntp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_convert_unix_time_to_ntp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gaf41c2bc4240e5b819fc7f285f62172a2">sl_sleeptimer_timestamp_t</a></td>          <td class="paramname"><span class="paramname"><em>time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>ntp_time</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts Unix timestamp into NTP timestamp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Unix timestamp. </td></tr>
    <tr><td class="paramname">ntp_time</td><td>Pointer to NTP Timestamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Unix timestamp range supported : 0x0 to 0x7C55 817F ie. January 1, 1970, 00:00:00 to February 07, 2036, 06:28:15</dd>
<dd>
Function definition is accessible only when SL_SLEEPTIMER_WALLCLOCK_CONFIG is set to 1.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="gaa73b94e0c15a1e2cf6b3cb0b37120ed4" name="gaa73b94e0c15a1e2cf6b3cb0b37120ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa73b94e0c15a1e2cf6b3cb0b37120ed4">&#9670;&#160;</a></span>sl_sleeptimer_convert_unix_time_to_zigbee()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_convert_unix_time_to_zigbee </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gaf41c2bc4240e5b819fc7f285f62172a2">sl_sleeptimer_timestamp_t</a></td>          <td class="paramname"><span class="paramname"><em>time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>zigbee_time</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts Unix timestamp into Zigbee timestamp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Unix timestamp.</td></tr>
    <tr><td class="paramname">zigbee_time</td><td>Pointer to NTP Timestamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Unix timestamp range supported : 0x386D 4380 to 0x7FFF FFFF ie. January 1, 2000, 00:00:0 to January 19, 2038, 03:14:00</dd>
<dd>
Function definition is accessible only when SL_SLEEPTIMER_WALLCLOCK_CONFIG is set to 1.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="gaab1267658b2ac5e4249e87412ce7dede" name="gaab1267658b2ac5e4249e87412ce7dede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab1267658b2ac5e4249e87412ce7dede">&#9670;&#160;</a></span>sl_sleeptimer_convert_zigbee_time_to_unix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_convert_zigbee_time_to_unix </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>zigbee_time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaf41c2bc4240e5b819fc7f285f62172a2">sl_sleeptimer_timestamp_t</a> *</td>          <td class="paramname"><span class="paramname"><em>time</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts Zigbee timestamp into Unix timestamp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zigbee_time</td><td>NTP Timestamp. </td></tr>
    <tr><td class="paramname">time</td><td>Pointer to Unix timestamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>ZIGBEE timestamp range supported : 0x0 to 0x4792 BC7F ie. January 1, 2000, 00:00:00 to January 19, 2038, 03:14:00</dd>
<dd>
Function definition is accessible only when SL_SLEEPTIMER_WALLCLOCK_CONFIG is set to 1.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="ga7d7c4ae596755e3e5e3c0c0aa5e749b3" name="ga7d7c4ae596755e3e5e3c0c0aa5e749b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d7c4ae596755e3e5e3c0c0aa5e749b3">&#9670;&#160;</a></span>sl_sleeptimer_delay_millisecond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sl_sleeptimer_delay_millisecond </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>time_ms</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Active delay.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_ms</td><td>Delay duration in milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c13ce5d0c1fc60a1596201932bb6b5f" name="ga4c13ce5d0c1fc60a1596201932bb6b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c13ce5d0c1fc60a1596201932bb6b5f">&#9670;&#160;</a></span>sl_sleeptimer_get_clock_accuracy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sl_sleeptimer_get_clock_accuracy </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the precision (in PPM) of the sleeptimer's clock. </p>
<dl class="section return"><dt>Returns</dt><dd>Clock accuracy, in PPM. </dd></dl>

</div>
</div>
<a id="ga2955c70feb8e0082ba54e30d2629d840" name="ga2955c70feb8e0082ba54e30d2629d840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2955c70feb8e0082ba54e30d2629d840">&#9670;&#160;</a></span>sl_sleeptimer_get_datetime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_get_datetime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga8b17c7e32e3ad35bb6b0a9c2001e8d64">sl_sleeptimer_date_t</a> *</td>          <td class="paramname"><span class="paramname"><em>date</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets current date.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date</td><td>Pointer to a sl_sleeptimer_date_t structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Time is in Standard Time.</dd>
<dd>
Function definition is accessible only when SL_SLEEPTIMER_WALLCLOCK_CONFIG is set to 1.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="ga3218039eab8d09231cc092fdc2a1dba5" name="ga3218039eab8d09231cc092fdc2a1dba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3218039eab8d09231cc092fdc2a1dba5">&#9670;&#160;</a></span>sl_sleeptimer_get_max_ms32_conversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sl_sleeptimer_get_max_ms32_conversion </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the maximum value that can be passed to the functions that have a 32-bits time or timeout argument expressed in milliseconds.</p>
<dl class="section return"><dt>Returns</dt><dd>Maximum time or timeout value in milliseconds.</dd></dl>
<p>Gets the maximum value that can be passed to the functions that have a 32-bits time or timeout argument expressed in milliseconds. </p>

</div>
</div>
<a id="gaf96ccea3e4d1727dc2fd2fa98f94ccb1" name="gaf96ccea3e4d1727dc2fd2fa98f94ccb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf96ccea3e4d1727dc2fd2fa98f94ccb1">&#9670;&#160;</a></span>sl_sleeptimer_get_remaining_time_of_first_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_get_remaining_time_of_first_timer </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>option_flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>time_remaining</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the time remaining until the first timer with the matching set of flags expires.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option_flags</td><td>Set of flags to match:<ul>
<li>SL_SLEEPTIMER_ANY_TIMER_FLAG</li>
<li>SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG</li>
</ul>
</td></tr>
    <tr><td class="paramname">time_remaining</td><td>Time left in timer ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise.</dd></dl>
<p>Gets the time remaining until the first timer with the matching set of flags expires. </p>

</div>
</div>
<a id="gae0397d420800b7c2d2afd5bbb9710067" name="gae0397d420800b7c2d2afd5bbb9710067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0397d420800b7c2d2afd5bbb9710067">&#9670;&#160;</a></span>sl_sleeptimer_get_tick_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sl_sleeptimer_get_tick_count </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets current 32 bits global tick count.</p>
<dl class="section return"><dt>Returns</dt><dd>Current tick count.</dd></dl>
<p>Gets current 32 bits tick count. </p>

</div>
</div>
<a id="gaaf928eeb3dad0d43098b3aed9049959a" name="gaaf928eeb3dad0d43098b3aed9049959a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf928eeb3dad0d43098b3aed9049959a">&#9670;&#160;</a></span>sl_sleeptimer_get_tick_count64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t sl_sleeptimer_get_tick_count64 </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets current 64 bits global tick count.</p>
<dl class="section return"><dt>Returns</dt><dd>Current tick count.</dd></dl>
<p>Gets current 64 bits tick count. </p>

</div>
</div>
<a id="ga4d79ef7aa10606814bcc21053bfca558" name="ga4d79ef7aa10606814bcc21053bfca558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d79ef7aa10606814bcc21053bfca558">&#9670;&#160;</a></span>sl_sleeptimer_get_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#gaf41c2bc4240e5b819fc7f285f62172a2">sl_sleeptimer_timestamp_t</a> sl_sleeptimer_get_time </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves current 32 bit time.</p>
<dl class="section note"><dt>Note</dt><dd>Function definition is accessible only when SL_SLEEPTIMER_WALLCLOCK_CONFIG is set to 1.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Current timestamps in Unix format. </dd></dl>

</div>
</div>
<a id="ga8e99647fc3da11223cf4e65b7ad8c52d" name="ga8e99647fc3da11223cf4e65b7ad8c52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e99647fc3da11223cf4e65b7ad8c52d">&#9670;&#160;</a></span>sl_sleeptimer_get_time_64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga5d4d9e5fe98012d2cffedb00caa9c91b">sl_sleeptimer_timestamp_64_t</a> sl_sleeptimer_get_time_64 </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves current 64 bit time.</p>
<dl class="section note"><dt>Note</dt><dd>Function definition is accessible only when SL_SLEEPTIMER_WALLCLOCK_CONFIG is set to 1.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Current timestamps in Unix format. </dd></dl>

</div>
</div>
<a id="ga69085e47b9cc43ac0cfdc08783c13aed" name="ga69085e47b9cc43ac0cfdc08783c13aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69085e47b9cc43ac0cfdc08783c13aed">&#9670;&#160;</a></span>sl_sleeptimer_get_timer_frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sl_sleeptimer_get_timer_frequency </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get timer frequency.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise.</dd></dl>
<p>Get timer frequency. </p>

</div>
</div>
<a id="ga6a06acb331e2e3c0efeb83f42a4d9c16" name="ga6a06acb331e2e3c0efeb83f42a4d9c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a06acb331e2e3c0efeb83f42a4d9c16">&#9670;&#160;</a></span>sl_sleeptimer_get_timer_time_remaining()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_get_timer_time_remaining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *</td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>time</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets remaining time until timer expires.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Pointer to handle to timer. </td></tr>
    <tr><td class="paramname">time</td><td>Time left in timer ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise.</dd></dl>
<p>Gets a 32 bits timer's time remaining. </p>

</div>
</div>
<a id="ga91ebac6960e114d933e1ef7c4f32294a" name="ga91ebac6960e114d933e1ef7c4f32294a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91ebac6960e114d933e1ef7c4f32294a">&#9670;&#160;</a></span>sl_sleeptimer_get_tz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga27148a3d37b9f3728cbd18b56b4c9979">sl_sleeptimer_time_zone_offset_t</a> sl_sleeptimer_get_tz </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets time zone offset.</p>
<dl class="section return"><dt>Returns</dt><dd>Time zone offset, in seconds. </dd></dl>

</div>
</div>
<a id="gae661a78719a6acc014efa15216ae4a54" name="gae661a78719a6acc014efa15216ae4a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae661a78719a6acc014efa15216ae4a54">&#9670;&#160;</a></span>sl_sleeptimer_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_init </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the Sleeptimer.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise.</dd></dl>
<p>Initializes sleep timer. </p>

</div>
</div>
<a id="ga0b38592836a9a01d6f315d417d3d6cd9" name="ga0b38592836a9a01d6f315d417d3d6cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b38592836a9a01d6f315d417d3d6cd9">&#9670;&#160;</a></span>sl_sleeptimer_is_power_manager_early_restore_timer_latest_to_expire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sl_sleeptimer_is_power_manager_early_restore_timer_latest_to_expire </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allow sleep after ISR exit.</p>
<dl class="section return"><dt>Returns</dt><dd>true if sleep is allowed after ISR exit. False otherwise.</dd></dl>
<p>Determines if the power manager's early wakeup expired during the last ISR and it was the only timer to expire in that period.</p>
<dl class="section return"><dt>Returns</dt><dd>true if power manager sleep can return to sleep, false otherwise. </dd></dl>

</div>
</div>
<a id="gac0236c1c353317c41d577867e7429874" name="gac0236c1c353317c41d577867e7429874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0236c1c353317c41d577867e7429874">&#9670;&#160;</a></span>sl_sleeptimer_is_timer_running()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_is_timer_running </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *</td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>running</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the status of a timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Pointer to handle to timer. </td></tr>
    <tr><td class="paramname">running</td><td>Pointer to the status of the timer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>A non periodic timer is considered not running during its callback.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise.</dd></dl>
<p>Gets the status of a timer. </p>

</div>
</div>
<a id="ga7484d4be4877b94a687f4410fccc6271" name="ga7484d4be4877b94a687f4410fccc6271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7484d4be4877b94a687f4410fccc6271">&#9670;&#160;</a></span>sl_sleeptimer_ms32_to_tick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_ms32_to_tick </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>time_ms</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>tick</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts 32-bits milliseconds in ticks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_ms</td><td>Number of milliseconds. </td></tr>
    <tr><td class="paramname">tick</td><td>Pointer to the converted tick number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The result is "rounded" to the superior tick number. If possible the <a class="el" href="#gadf3a3eb05b0f5adbc7ee488113299f61">sl_sleeptimer_ms_to_tick()</a> function should be used.</dd>
<dd>
This function converts the delay expressed in milliseconds to timer ticks (represented on 32 bits). This means that the value that can be passed to the argument 'time_ms' is limited. The maximum timeout value that can be passed to this function can be retrieved by calling <a class="el" href="#ga3218039eab8d09231cc092fdc2a1dba5">sl_sleeptimer_get_max_ms32_conversion()</a>. If the value passed to 'time_ms' is too large, SL_STATUS_INVALID_PARAMETER will be returned. </dd></dl>

</div>
</div>
<a id="gadf3a3eb05b0f5adbc7ee488113299f61" name="gadf3a3eb05b0f5adbc7ee488113299f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf3a3eb05b0f5adbc7ee488113299f61">&#9670;&#160;</a></span>sl_sleeptimer_ms_to_tick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sl_sleeptimer_ms_to_tick </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>time_ms</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts milliseconds in ticks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_ms</td><td>Number of milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Corresponding ticks number.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The result is "rounded" to the superior tick number. This function is light and cannot fail so it should be privilegied to perform a millisecond to tick conversion. </dd></dl>

</div>
</div>
<a id="gaf54408a7f172b684de33d9a7f4e01be9" name="gaf54408a7f172b684de33d9a7f4e01be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf54408a7f172b684de33d9a7f4e01be9">&#9670;&#160;</a></span>sl_sleeptimer_restart_periodic_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_restart_periodic_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *</td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga9049589e4153204fb3e97cbe1ecda89b">sl_sleeptimer_timer_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>callback_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>priority</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>option_flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restarts a 32 bits periodic timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Pointer to handle to timer. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timer periodic timeout, in timer ticks. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback function that will be called when initial/periodic timeout expires. </td></tr>
    <tr><td class="paramname">callback_data</td><td>Pointer to user data that will be passed to callback. </td></tr>
    <tr><td class="paramname">priority</td><td>Priority of callback. Useful in case multiple timer expire at the same time. 0 = highest priority. </td></tr>
    <tr><td class="paramname">option_flags</td><td>Bit array of option flags for the timer. Valid bit-wise OR of one or more of the following:<ul>
<li>SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG or 0 for not flags.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise.</dd></dl>
<p>Restarts a 32 bits periodic timer. </p>

</div>
</div>
<a id="ga1a44174e7a8eccbabde499875cb8462a" name="ga1a44174e7a8eccbabde499875cb8462a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a44174e7a8eccbabde499875cb8462a">&#9670;&#160;</a></span>sl_sleeptimer_restart_periodic_timer_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_restart_periodic_timer_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *</td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga9049589e4153204fb3e97cbe1ecda89b">sl_sleeptimer_timer_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>callback_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>priority</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>option_flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restarts a 32 bits periodic timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Pointer to handle to timer. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timer periodic timeout, in milliseconds. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback function that will be called when initial/periodic timeout expires. </td></tr>
    <tr><td class="paramname">callback_data</td><td>Pointer to user data that will be passed to callback. </td></tr>
    <tr><td class="paramname">priority</td><td>Priority of callback. Useful in case multiple timer expire at the same time. 0 = highest priority. </td></tr>
    <tr><td class="paramname">option_flags</td><td>Bit array of option flags for the timer. Valid bit-wise OR of one or more of the following:<ul>
<li>SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG or 0 for not flags.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function converts the delay expressed in milliseconds to timer ticks (represented on 32 bits). This means that the value that can be passed to the argument 'timeout_ms' is limited. The maximum timeout value that can be passed to this function can be retrieved by calling <a class="el" href="#ga3218039eab8d09231cc092fdc2a1dba5">sl_sleeptimer_get_max_ms32_conversion()</a>. If the value passed to 'timeout_ms' is too large, SL_STATUS_INVALID_PARAMETER will be returned.</dd></dl>
<p>Restarts a 32 bits periodic timer using milliseconds as the timebase. </p>

</div>
</div>
<a id="gaacd5a666731a0ba4823107e552e23e69" name="gaacd5a666731a0ba4823107e552e23e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacd5a666731a0ba4823107e552e23e69">&#9670;&#160;</a></span>sl_sleeptimer_restart_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_restart_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *</td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga9049589e4153204fb3e97cbe1ecda89b">sl_sleeptimer_timer_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>callback_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>priority</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>option_flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restarts a 32 bits timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Pointer to handle to timer. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timer timeout, in timer ticks. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback function that will be called when initial/periodic timeout expires. </td></tr>
    <tr><td class="paramname">callback_data</td><td>Pointer to user data that will be passed to callback. </td></tr>
    <tr><td class="paramname">priority</td><td>Priority of callback. Useful in case multiple timer expire at the same time. 0 = highest priority. </td></tr>
    <tr><td class="paramname">option_flags</td><td>Bit array of option flags for the timer. Valid bit-wise OR of one or more of the following:<ul>
<li>SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG or 0 for not flags.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise.</dd></dl>
<p>Restarts a 32 bits timer. </p>

</div>
</div>
<a id="gab3da1641c9bae0857ba3cffcbc41f21a" name="gab3da1641c9bae0857ba3cffcbc41f21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3da1641c9bae0857ba3cffcbc41f21a">&#9670;&#160;</a></span>sl_sleeptimer_restart_timer_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE sl_status_t sl_sleeptimer_restart_timer_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *</td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga9049589e4153204fb3e97cbe1ecda89b">sl_sleeptimer_timer_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>callback_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>priority</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>option_flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restarts a 32 bits timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Pointer to handle to timer. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timer timeout, in milliseconds. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback function that will be called when initial/periodic timeout expires. </td></tr>
    <tr><td class="paramname">callback_data</td><td>Pointer to user data that will be passed to callback. </td></tr>
    <tr><td class="paramname">priority</td><td>Priority of callback. Useful in case multiple timer expire at the same time. 0 = highest priority. </td></tr>
    <tr><td class="paramname">option_flags</td><td>Bit array of option flags for the timer. Valid bit-wise OR of one or more of the following:<ul>
<li>SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG or 0 for not flags.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function converts the delay expressed in milliseconds to timer ticks (represented on 32 bits). This means that the value that can be passed to the argument 'timeout_ms' is limited. The maximum timeout value that can be passed to this function can be retrieved by calling <a class="el" href="#ga3218039eab8d09231cc092fdc2a1dba5">sl_sleeptimer_get_max_ms32_conversion()</a>. If the value passed to 'timeout_ms' is too large, SL_STATUS_INVALID_PARAMETER will be returned. </dd></dl>

</div>
</div>
<a id="ga840c8ef8049b364a45899320a9f0c8bf" name="ga840c8ef8049b364a45899320a9f0c8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga840c8ef8049b364a45899320a9f0c8bf">&#9670;&#160;</a></span>sl_sleeptimer_set_datetime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_set_datetime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga8b17c7e32e3ad35bb6b0a9c2001e8d64">sl_sleeptimer_date_t</a> *</td>          <td class="paramname"><span class="paramname"><em>date</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets current time, in date format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date</td><td>Pointer to current date.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Function definition is accessible only when SL_SLEEPTIMER_WALLCLOCK_CONFIG is set to 1.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="gafbd64c7fbf7b0dfb7947a6f7bf288dca" name="gafbd64c7fbf7b0dfb7947a6f7bf288dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbd64c7fbf7b0dfb7947a6f7bf288dca">&#9670;&#160;</a></span>sl_sleeptimer_set_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_set_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gaf41c2bc4240e5b819fc7f285f62172a2">sl_sleeptimer_timestamp_t</a></td>          <td class="paramname"><span class="paramname"><em>time</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets current time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>timestamp structure to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Function definition is accessible only when SL_SLEEPTIMER_WALLCLOCK_CONFIG is set to 1.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="ga63a00c3c2b137b68f66d47ae77f0d26b" name="ga63a00c3c2b137b68f66d47ae77f0d26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63a00c3c2b137b68f66d47ae77f0d26b">&#9670;&#160;</a></span>sl_sleeptimer_set_time_64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_set_time_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga5d4d9e5fe98012d2cffedb00caa9c91b">sl_sleeptimer_timestamp_64_t</a></td>          <td class="paramname"><span class="paramname"><em>time</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets current time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>timestamp structure to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Function definition is accessible only when SL_SLEEPTIMER_WALLCLOCK_CONFIG is set to 1.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="gafbd748d9a4654e9ae474a7020a5d9813" name="gafbd748d9a4654e9ae474a7020a5d9813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbd748d9a4654e9ae474a7020a5d9813">&#9670;&#160;</a></span>sl_sleeptimer_set_tz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sl_sleeptimer_set_tz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga27148a3d37b9f3728cbd18b56b4c9979">sl_sleeptimer_time_zone_offset_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets time zone offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Time zone offset, in seconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Function definition is accessible only when SL_SLEEPTIMER_WALLCLOCK_CONFIG is set to 1. </dd></dl>

</div>
</div>
<a id="ga173dc0338a7c53c13c73a4859158b901" name="ga173dc0338a7c53c13c73a4859158b901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga173dc0338a7c53c13c73a4859158b901">&#9670;&#160;</a></span>sl_sleeptimer_set_tz_ahead_utc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="#ga27148a3d37b9f3728cbd18b56b4c9979">sl_sleeptimer_time_zone_offset_t</a> sl_sleeptimer_set_tz_ahead_utc </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>hours</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>minutes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates offset for time zone after UTC-0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hours</td><td>Number of hours from UTC-0. </td></tr>
    <tr><td class="paramname">minutes</td><td>Number of minutes from UTC-0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The time zone offset in seconds. </dd></dl>

</div>
</div>
<a id="gafd73a4283a8c257f8e9c74f410679073" name="gafd73a4283a8c257f8e9c74f410679073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd73a4283a8c257f8e9c74f410679073">&#9670;&#160;</a></span>sl_sleeptimer_set_tz_behind_utc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="#ga27148a3d37b9f3728cbd18b56b4c9979">sl_sleeptimer_time_zone_offset_t</a> sl_sleeptimer_set_tz_behind_utc </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>hours</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>minutes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates offset for time zone before UTC-0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hours</td><td>Number of hours to UTC-0. </td></tr>
    <tr><td class="paramname">minutes</td><td>Number of minutes to UTC-0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The time zone offset in seconds. </dd></dl>

</div>
</div>
<a id="ga2ceb1b76334902525dd32e937e90bb16" name="ga2ceb1b76334902525dd32e937e90bb16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ceb1b76334902525dd32e937e90bb16">&#9670;&#160;</a></span>sl_sleeptimer_start_periodic_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_start_periodic_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *</td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga9049589e4153204fb3e97cbe1ecda89b">sl_sleeptimer_timer_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>callback_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>priority</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>option_flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts a 32 bits periodic timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Pointer to handle to timer. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timer periodic timeout, in timer ticks. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback function that will be called when initial/periodic timeout expires. </td></tr>
    <tr><td class="paramname">callback_data</td><td>Pointer to user data that will be passed to callback. </td></tr>
    <tr><td class="paramname">priority</td><td>Priority of callback. Useful in case multiple timer expire at the same time. 0 = highest priority. </td></tr>
    <tr><td class="paramname">option_flags</td><td>Bit array of option flags for the timer. Valid bit-wise OR of one or more of the following:<ul>
<li>SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG or 0 for not flags.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise.</dd></dl>
<p>Starts a 32 bits periodic timer. </p>

</div>
</div>
<a id="gae4639653b4bf4ed68049b2a12a6c6d83" name="gae4639653b4bf4ed68049b2a12a6c6d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4639653b4bf4ed68049b2a12a6c6d83">&#9670;&#160;</a></span>sl_sleeptimer_start_periodic_timer_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_start_periodic_timer_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *</td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga9049589e4153204fb3e97cbe1ecda89b">sl_sleeptimer_timer_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>callback_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>priority</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>option_flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts a 32 bits periodic timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Pointer to handle to timer. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timer periodic timeout, in milliseconds. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback function that will be called when initial/periodic timeout expires. </td></tr>
    <tr><td class="paramname">callback_data</td><td>Pointer to user data that will be passed to callback. </td></tr>
    <tr><td class="paramname">priority</td><td>Priority of callback. Useful in case multiple timer expire at the same time. 0 = highest priority. </td></tr>
    <tr><td class="paramname">option_flags</td><td>Bit array of option flags for the timer. Valid bit-wise OR of one or more of the following:<ul>
<li>SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG or 0 for not flags.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function converts the delay expressed in milliseconds to timer ticks (represented on 32 bits). This means that the value that can be passed to the argument 'timeout_ms' is limited. The maximum timeout value that can be passed to this function can be retrieved by calling <a class="el" href="#ga3218039eab8d09231cc092fdc2a1dba5">sl_sleeptimer_get_max_ms32_conversion()</a>. If the value passed to 'timeout_ms' is too large, SL_STATUS_INVALID_PARAMETER will be returned.</dd></dl>
<p>Starts a 32 bits periodic timer using milliseconds as the timebase. </p>

</div>
</div>
<a id="ga43c32bdb2a9fcfbe279563a9fd689711" name="ga43c32bdb2a9fcfbe279563a9fd689711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43c32bdb2a9fcfbe279563a9fd689711">&#9670;&#160;</a></span>sl_sleeptimer_start_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_start_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *</td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga9049589e4153204fb3e97cbe1ecda89b">sl_sleeptimer_timer_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>callback_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>priority</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>option_flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts a 32 bits timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Pointer to handle to timer. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timer timeout, in timer ticks. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback function that will be called when initial/periodic timeout expires. </td></tr>
    <tr><td class="paramname">callback_data</td><td>Pointer to user data that will be passed to callback. </td></tr>
    <tr><td class="paramname">priority</td><td>Priority of callback. Useful in case multiple timer expire at the same time. 0 = highest priority. </td></tr>
    <tr><td class="paramname">option_flags</td><td>Bit array of option flags for the timer. Valid bit-wise OR of one or more of the following:<ul>
<li>SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG or 0 for not flags.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise.</dd></dl>
<p>Starts a 32 bits timer. </p>

</div>
</div>
<a id="gadcb95c35f7307d91df1818e71f6540d2" name="gadcb95c35f7307d91df1818e71f6540d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcb95c35f7307d91df1818e71f6540d2">&#9670;&#160;</a></span>sl_sleeptimer_start_timer_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE sl_status_t sl_sleeptimer_start_timer_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *</td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout_ms</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga9049589e4153204fb3e97cbe1ecda89b">sl_sleeptimer_timer_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>callback_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>priority</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>option_flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts a 32 bits timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Pointer to handle to timer. </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timer timeout, in milliseconds. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback function that will be called when initial/periodic timeout expires. </td></tr>
    <tr><td class="paramname">callback_data</td><td>Pointer to user data that will be passed to callback. </td></tr>
    <tr><td class="paramname">priority</td><td>Priority of callback. Useful in case multiple timer expire at the same time. 0 = highest priority. </td></tr>
    <tr><td class="paramname">option_flags</td><td>Bit array of option flags for the timer. Valid bit-wise OR of one or more of the following:<ul>
<li>SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG or 0 for not flags.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function converts the delay expressed in milliseconds to timer ticks (represented on 32 bits). This means that the value that can be passed to the argument 'timeout_ms' is limited. The maximum timeout value that can be passed to this function can be retrieved by calling <a class="el" href="#ga3218039eab8d09231cc092fdc2a1dba5">sl_sleeptimer_get_max_ms32_conversion()</a>. If the value passed to 'timeout_ms' is too large, SL_STATUS_INVALID_PARAMETER will be returned. </dd></dl>

</div>
</div>
<a id="ga1f4f25aa754cd35214dba9762450b0ca" name="ga1f4f25aa754cd35214dba9762450b0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f4f25aa754cd35214dba9762450b0ca">&#9670;&#160;</a></span>sl_sleeptimer_stop_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_stop_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl__sleeptimer__timer__handle.html">sl_sleeptimer_timer_handle_t</a> *</td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops a timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Pointer to handle to timer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>Stops a 32 bits timer. </p>

</div>
</div>
<a id="ga6882d0577137d8e20ec531be45678fba" name="ga6882d0577137d8e20ec531be45678fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6882d0577137d8e20ec531be45678fba">&#9670;&#160;</a></span>sl_sleeptimer_tick64_to_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t sl_sleeptimer_tick64_to_ms </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>tick</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *</td>          <td class="paramname"><span class="paramname"><em>ms</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts 64-bit ticks in milliseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tick</td><td>Number of tick. </td></tr>
    <tr><td class="paramname">ms</td><td>Pointer to the converted milliseconds number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. Error code otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The result is rounded to the inferior millisecond. </dd></dl>

</div>
</div>
<a id="ga2c2a2a131e401894d3e09513442667b5" name="ga2c2a2a131e401894d3e09513442667b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c2a2a131e401894d3e09513442667b5">&#9670;&#160;</a></span>sl_sleeptimer_tick_to_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sl_sleeptimer_tick_to_ms </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>tick</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts ticks in milliseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tick</td><td>Number of tick.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Corresponding milliseconds number.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The result is rounded to the inferior millisecond. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
