<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BSzF - HF - Buranszki/Tamasy: UARTDRV - UART Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">BSzF - HF - Buranszki/Tamasy
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Topics</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">UARTDRV - UART Driver</div></div>
</div><!--header-->
<div class="contents">

<p>Universal Asynchronous Receiver/Transmitter Driver.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Topics</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartdrv__error__codes.html">Error Codes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uartdrv__status__codes.html">Status Codes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t_d_r_v___buffer__t.html">UARTDRV_Buffer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART transfer buffer.  <a href="struct_u_a_r_t_d_r_v___buffer__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t_d_r_v___buffer___fifo_queue__t.html">UARTDRV_Buffer_FifoQueue_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer operation FIFO queue typedef.  <a href="struct_u_a_r_t_d_r_v___buffer___fifo_queue__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t_d_r_v___handle_data.html">UARTDRV_HandleData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gabe460e78b696ee85a78db220e5f6ec89" id="r_gabe460e78b696ee85a78db220e5f6ec89"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabe460e78b696ee85a78db220e5f6ec89">EMDRV_UARTDRV_MAX_CONCURRENT_RX_BUFS</a>&#160;&#160;&#160;6</td></tr>
<tr class="separator:gabe460e78b696ee85a78db220e5f6ec89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a5792abd05dc9ec1eb1c2fa0e9b9d6a" id="r_ga1a5792abd05dc9ec1eb1c2fa0e9b9d6a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1a5792abd05dc9ec1eb1c2fa0e9b9d6a">EMDRV_UARTDRV_MAX_CONCURRENT_TX_BUFS</a>&#160;&#160;&#160;6</td></tr>
<tr class="separator:ga1a5792abd05dc9ec1eb1c2fa0e9b9d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae325304971b4f6d0e7ddc6ce8b931fd2" id="r_gae325304971b4f6d0e7ddc6ce8b931fd2"><td class="memItemLeft" align="right" valign="top"><a id="gae325304971b4f6d0e7ddc6ce8b931fd2" name="gae325304971b4f6d0e7ddc6ce8b931fd2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EMDRV_UARTDRV_FLOW_CONTROL_ENABLE</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gae325304971b4f6d0e7ddc6ce8b931fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to 1 to include flow control support. <br /></td></tr>
<tr class="separator:gae325304971b4f6d0e7ddc6ce8b931fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaede5027a4c6873b9679f0b6df1acd11c" id="r_gaede5027a4c6873b9679f0b6df1acd11c"><td class="memItemLeft" align="right" valign="top"><a id="gaede5027a4c6873b9679f0b6df1acd11c" name="gaede5027a4c6873b9679f0b6df1acd11c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EMDRV_UARTDRV_MAX_DRIVER_INSTANCES</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:gaede5027a4c6873b9679f0b6df1acd11c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of driver instances. <br /></td></tr>
<tr class="separator:gaede5027a4c6873b9679f0b6df1acd11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d5de1353096abcc856b6ad24abc60bb" id="r_ga0d5de1353096abcc856b6ad24abc60bb"><td class="memItemLeft" align="right" valign="top"><a id="ga0d5de1353096abcc856b6ad24abc60bb" name="ga0d5de1353096abcc856b6ad24abc60bb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UARTDRV_FC_SW_XON</b>&#160;&#160;&#160;0x11</td></tr>
<tr class="memdesc:ga0d5de1353096abcc856b6ad24abc60bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART software flow control code: request peer to start TX. <br /></td></tr>
<tr class="separator:ga0d5de1353096abcc856b6ad24abc60bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga528f36160480e9caadd6bdad3f61765c" id="r_ga528f36160480e9caadd6bdad3f61765c"><td class="memItemLeft" align="right" valign="top"><a id="ga528f36160480e9caadd6bdad3f61765c" name="ga528f36160480e9caadd6bdad3f61765c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UARTDRV_FC_SW_XOFF</b>&#160;&#160;&#160;0x13</td></tr>
<tr class="memdesc:ga528f36160480e9caadd6bdad3f61765c"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART software flow control code: request peer to stop TX. <br /></td></tr>
<tr class="separator:ga528f36160480e9caadd6bdad3f61765c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9201ffeb719cd15b70e27068a0f61be2" id="r_ga9201ffeb719cd15b70e27068a0f61be2"><td class="memItemLeft" align="right" valign="top"><a id="ga9201ffeb719cd15b70e27068a0f61be2" name="ga9201ffeb719cd15b70e27068a0f61be2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UARTDRV_RESTRICT_ENERGY_MODE_TO_ALLOW_RECEPTION</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga9201ffeb719cd15b70e27068a0f61be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART enable reception when sleeping. <br /></td></tr>
<tr class="separator:ga9201ffeb719cd15b70e27068a0f61be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24318918f06c584749d8a2f8a96be2fc" id="r_ga24318918f06c584749d8a2f8a96be2fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga24318918f06c584749d8a2f8a96be2fc">DEFINE_BUF_QUEUE</a>(qSize,  qName)</td></tr>
<tr class="separator:ga24318918f06c584749d8a2f8a96be2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga20f2dca466c884ed896061f8e90ff816" id="r_ga20f2dca466c884ed896061f8e90ff816"><td class="memItemLeft" align="right" valign="top"><a id="ga20f2dca466c884ed896061f8e90ff816" name="ga20f2dca466c884ed896061f8e90ff816"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>UARTDRV_Count_t</b></td></tr>
<tr class="memdesc:ga20f2dca466c884ed896061f8e90ff816"><td class="mdescLeft">&#160;</td><td class="mdescRight">A UART transfer count. <br /></td></tr>
<tr class="separator:ga20f2dca466c884ed896061f8e90ff816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1cf3e2748cf7a377fe60f055c07c3a6" id="r_gae1cf3e2748cf7a377fe60f055c07c3a6"><td class="memItemLeft" align="right" valign="top"><a id="gae1cf3e2748cf7a377fe60f055c07c3a6" name="gae1cf3e2748cf7a377fe60f055c07c3a6"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>UARTDRV_Status_t</b></td></tr>
<tr class="memdesc:gae1cf3e2748cf7a377fe60f055c07c3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A UART status return type. Bitfield of UARTDRV_STATUS_* values. <br /></td></tr>
<tr class="separator:gae1cf3e2748cf7a377fe60f055c07c3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75a7670b4c9deaa47bc197bbde9b7fb4" id="r_ga75a7670b4c9deaa47bc197bbde9b7fb4"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga75a7670b4c9deaa47bc197bbde9b7fb4">UARTDRV_Callback_t</a>) (struct <a class="el" href="struct_u_a_r_t_d_r_v___handle_data.html">UARTDRV_HandleData</a> *handle, <a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a> transferStatus, uint8_t *data, <a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a> transferCount)</td></tr>
<tr class="memdesc:ga75a7670b4c9deaa47bc197bbde9b7fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">UARTDRV transfer completion callback function.  <br /></td></tr>
<tr class="separator:ga75a7670b4c9deaa47bc197bbde9b7fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac38a311be86450bee230b5bf111cecf3" id="r_gac38a311be86450bee230b5bf111cecf3"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_a_r_t_d_r_v___handle_data.html">UARTDRV_HandleData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac38a311be86450bee230b5bf111cecf3">UARTDRV_HandleData_t</a></td></tr>
<tr class="separator:gac38a311be86450bee230b5bf111cecf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga559d69d7978a815087a905fb13af15ea" id="r_ga559d69d7978a815087a905fb13af15ea"><td class="memItemLeft" align="right" valign="top"><a id="ga559d69d7978a815087a905fb13af15ea" name="ga559d69d7978a815087a905fb13af15ea"></a>
typedef <a class="el" href="#gac38a311be86450bee230b5bf111cecf3">UARTDRV_HandleData_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>UARTDRV_Handle_t</b></td></tr>
<tr class="memdesc:ga559d69d7978a815087a905fb13af15ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle pointer. <br /></td></tr>
<tr class="separator:ga559d69d7978a815087a905fb13af15ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadd561e294765dfb017374057fd99ceb8" id="r_gadd561e294765dfb017374057fd99ceb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadd561e294765dfb017374057fd99ceb8">SL_ENUM</a> (UARTDRV_FlowControlType_t)</td></tr>
<tr class="separator:gadd561e294765dfb017374057fd99ceb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88d8ed44e5de7fddff07b6f98c6be21f" id="r_ga88d8ed44e5de7fddff07b6f98c6be21f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga88d8ed44e5de7fddff07b6f98c6be21f">SL_ENUM</a> (UARTDRV_FlowControlState_t)</td></tr>
<tr class="memdesc:ga88d8ed44e5de7fddff07b6f98c6be21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flow Control state.  <br /></td></tr>
<tr class="separator:ga88d8ed44e5de7fddff07b6f98c6be21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0111d9b9c81c8b15cfde60ac8d19c36c" id="r_ga0111d9b9c81c8b15cfde60ac8d19c36c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0111d9b9c81c8b15cfde60ac8d19c36c">SL_ENUM</a> (UARTDRV_AbortType_t)</td></tr>
<tr class="memdesc:ga0111d9b9c81c8b15cfde60ac8d19c36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer abort type.  <br /></td></tr>
<tr class="separator:ga0111d9b9c81c8b15cfde60ac8d19c36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b4222031534ab6d54ca068b5fa6e596" id="r_ga3b4222031534ab6d54ca068b5fa6e596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3b4222031534ab6d54ca068b5fa6e596">UARTDRV_DeInit</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle)</td></tr>
<tr class="memdesc:ga3b4222031534ab6d54ca068b5fa6e596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialize a UART driver instance.  <br /></td></tr>
<tr class="separator:ga3b4222031534ab6d54ca068b5fa6e596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38e53b4e39e17d0f7be9034ef11eb534" id="r_ga38e53b4e39e17d0f7be9034ef11eb534"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#gae1cf3e2748cf7a377fe60f055c07c3a6">UARTDRV_Status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga38e53b4e39e17d0f7be9034ef11eb534">UARTDRV_GetPeripheralStatus</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle)</td></tr>
<tr class="memdesc:ga38e53b4e39e17d0f7be9034ef11eb534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the UART peripheral associated with a given handle.  <br /></td></tr>
<tr class="separator:ga38e53b4e39e17d0f7be9034ef11eb534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34806bf9fc4d876aa6ae725ce060541b" id="r_ga34806bf9fc4d876aa6ae725ce060541b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#gae1cf3e2748cf7a377fe60f055c07c3a6">UARTDRV_Status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga34806bf9fc4d876aa6ae725ce060541b">UARTDRV_GetReceiveStatus</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle, uint8_t **buffer, <a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a> *bytesReceived, <a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a> *bytesRemaining)</td></tr>
<tr class="memdesc:ga34806bf9fc4d876aa6ae725ce060541b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the status of the UART and gather information about any ongoing receive operations.  <br /></td></tr>
<tr class="separator:ga34806bf9fc4d876aa6ae725ce060541b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5387109fb659840fa822aa6ae08b81f" id="r_gae5387109fb659840fa822aa6ae08b81f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#gae1cf3e2748cf7a377fe60f055c07c3a6">UARTDRV_Status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae5387109fb659840fa822aa6ae08b81f">UARTDRV_GetTransmitStatus</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle, uint8_t **buffer, <a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a> *bytesSent, <a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a> *bytesRemaining)</td></tr>
<tr class="memdesc:gae5387109fb659840fa822aa6ae08b81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the status of the UART and gather information about any ongoing transmit operations.  <br /></td></tr>
<tr class="separator:gae5387109fb659840fa822aa6ae08b81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b0230941575668b73874ffe1ff01e4" id="r_gab9b0230941575668b73874ffe1ff01e4"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab9b0230941575668b73874ffe1ff01e4">UARTDRV_GetReceiveDepth</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle)</td></tr>
<tr class="memdesc:gab9b0230941575668b73874ffe1ff01e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of queued receive operations.  <br /></td></tr>
<tr class="separator:gab9b0230941575668b73874ffe1ff01e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab467cb6aa9940119e4f03bd860c76266" id="r_gab467cb6aa9940119e4f03bd860c76266"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab467cb6aa9940119e4f03bd860c76266">UARTDRV_GetTransmitDepth</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle)</td></tr>
<tr class="memdesc:gab467cb6aa9940119e4f03bd860c76266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of queued transmit operations.  <br /></td></tr>
<tr class="separator:gab467cb6aa9940119e4f03bd860c76266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga484ac0b78a9eccb0ec6a1d30b7cc3232" id="r_ga484ac0b78a9eccb0ec6a1d30b7cc3232"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga484ac0b78a9eccb0ec6a1d30b7cc3232">UARTDRV_Transmit</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle, uint8_t *data, <a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a> count, <a class="el" href="#ga75a7670b4c9deaa47bc197bbde9b7fb4">UARTDRV_Callback_t</a> callback)</td></tr>
<tr class="memdesc:ga484ac0b78a9eccb0ec6a1d30b7cc3232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a non-blocking transmit.  <br /></td></tr>
<tr class="separator:ga484ac0b78a9eccb0ec6a1d30b7cc3232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d8a5e61c33176ad32cf3c1330e132c6" id="r_ga1d8a5e61c33176ad32cf3c1330e132c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1d8a5e61c33176ad32cf3c1330e132c6">UARTDRV_Receive</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle, uint8_t *data, <a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a> count, <a class="el" href="#ga75a7670b4c9deaa47bc197bbde9b7fb4">UARTDRV_Callback_t</a> callback)</td></tr>
<tr class="memdesc:ga1d8a5e61c33176ad32cf3c1330e132c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a non-blocking receive.  <br /></td></tr>
<tr class="separator:ga1d8a5e61c33176ad32cf3c1330e132c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58f8120e861e2d9335e2acceec1ae4f7" id="r_ga58f8120e861e2d9335e2acceec1ae4f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga58f8120e861e2d9335e2acceec1ae4f7">UARTDRV_TransmitB</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle, uint8_t *data, <a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a> count)</td></tr>
<tr class="memdesc:ga58f8120e861e2d9335e2acceec1ae4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a blocking transmit.  <br /></td></tr>
<tr class="separator:ga58f8120e861e2d9335e2acceec1ae4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d8380296aa482ac95360d3855a2e150" id="r_ga5d8380296aa482ac95360d3855a2e150"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5d8380296aa482ac95360d3855a2e150">UARTDRV_ReceiveB</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle, uint8_t *data, <a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a> count)</td></tr>
<tr class="memdesc:ga5d8380296aa482ac95360d3855a2e150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a blocking receive.  <br /></td></tr>
<tr class="separator:ga5d8380296aa482ac95360d3855a2e150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762bade408c1a64812467e1f58026899" id="r_ga762bade408c1a64812467e1f58026899"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga762bade408c1a64812467e1f58026899">UARTDRV_ForceTransmit</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle, uint8_t *data, <a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a> count)</td></tr>
<tr class="memdesc:ga762bade408c1a64812467e1f58026899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct transmit without interrupts or callback. This is a blocking function. that ignores flow control if enabled.  <br /></td></tr>
<tr class="separator:ga762bade408c1a64812467e1f58026899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac978c9e489a78347598b3005bb49545e" id="r_gac978c9e489a78347598b3005bb49545e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac978c9e489a78347598b3005bb49545e">UARTDRV_ForceReceive</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle, uint8_t *data, <a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a> maxLength)</td></tr>
<tr class="memdesc:gac978c9e489a78347598b3005bb49545e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct receive without interrupts or callback. This is a blocking function.  <br /></td></tr>
<tr class="separator:gac978c9e489a78347598b3005bb49545e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0abd859c2a17dafe03abceeb4c96a12a" id="r_ga0abd859c2a17dafe03abceeb4c96a12a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0abd859c2a17dafe03abceeb4c96a12a">UARTDRV_Abort</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle, UARTDRV_AbortType_t type)</td></tr>
<tr class="memdesc:ga0abd859c2a17dafe03abceeb4c96a12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort ongoing UART transfers.  <br /></td></tr>
<tr class="separator:ga0abd859c2a17dafe03abceeb4c96a12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa7cbc80545ad814f338c4043de5023c" id="r_gafa7cbc80545ad814f338c4043de5023c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafa7cbc80545ad814f338c4043de5023c">UARTDRV_PauseTransmit</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle)</td></tr>
<tr class="memdesc:gafa7cbc80545ad814f338c4043de5023c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause an ongoing transmit operation.  <br /></td></tr>
<tr class="separator:gafa7cbc80545ad814f338c4043de5023c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e83c35be3ad93e6717ce8dc54a155c7" id="r_ga6e83c35be3ad93e6717ce8dc54a155c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6e83c35be3ad93e6717ce8dc54a155c7">UARTDRV_ResumeTransmit</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle)</td></tr>
<tr class="memdesc:ga6e83c35be3ad93e6717ce8dc54a155c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a paused transmit operation.  <br /></td></tr>
<tr class="separator:ga6e83c35be3ad93e6717ce8dc54a155c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54bed0223f912f7a5a5e1c4a62356ffe" id="r_ga54bed0223f912f7a5a5e1c4a62356ffe"><td class="memItemLeft" align="right" valign="top">UARTDRV_FlowControlState_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga54bed0223f912f7a5a5e1c4a62356ffe">UARTDRV_FlowControlGetSelfStatus</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle)</td></tr>
<tr class="memdesc:ga54bed0223f912f7a5a5e1c4a62356ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the self flow control status.  <br /></td></tr>
<tr class="separator:ga54bed0223f912f7a5a5e1c4a62356ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ba0e9be643afcefc0962dcdb2e635a7" id="r_ga3ba0e9be643afcefc0962dcdb2e635a7"><td class="memItemLeft" align="right" valign="top">UARTDRV_FlowControlState_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3ba0e9be643afcefc0962dcdb2e635a7">UARTDRV_FlowControlGetPeerStatus</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle)</td></tr>
<tr class="memdesc:ga3ba0e9be643afcefc0962dcdb2e635a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the peer's flow control status.  <br /></td></tr>
<tr class="separator:ga3ba0e9be643afcefc0962dcdb2e635a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga793738f4fce0d507867e3a56d36426d2" id="r_ga793738f4fce0d507867e3a56d36426d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga793738f4fce0d507867e3a56d36426d2">UARTDRV_FlowControlSet</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle, UARTDRV_FlowControlState_t state)</td></tr>
<tr class="memdesc:ga793738f4fce0d507867e3a56d36426d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set UART flow control state. Set nRTS pin if hardware flow control is enabled. Send XON/XOFF if software flow control is enabled.  <br /></td></tr>
<tr class="separator:ga793738f4fce0d507867e3a56d36426d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga110407a69b9915d78980749b449a106c" id="r_ga110407a69b9915d78980749b449a106c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga110407a69b9915d78980749b449a106c">UARTDRV_FlowControlSetPeerStatus</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle, UARTDRV_FlowControlState_t state)</td></tr>
<tr class="memdesc:ga110407a69b9915d78980749b449a106c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set peer UART flow control state. Pause/resume transmit accordingly. Only for manual software flow control.  <br /></td></tr>
<tr class="separator:ga110407a69b9915d78980749b449a106c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e0d51c55deaa14695b276c3c19cd4a1" id="r_ga8e0d51c55deaa14695b276c3c19cd4a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8e0d51c55deaa14695b276c3c19cd4a1">UARTDRV_FlowControlIgnoreRestrain</a> (<a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a> handle)</td></tr>
<tr class="memdesc:ga8e0d51c55deaa14695b276c3c19cd4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable transmission when restrained by flow control.  <br /></td></tr>
<tr class="separator:ga8e0d51c55deaa14695b276c3c19cd4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Universal Asynchronous Receiver/Transmitter Driver. </p>
<p>The source files for the UART driver library, <a class="el" href="uartdrv_8c.html" title="UARTDRV API implementation.">uartdrv.c</a> and <a class="el" href="uartdrv_8h.html" title="UARTDRV API definition.">uartdrv.h</a>, are in the emdrv/uartdrv folder.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="uartdrv_intro"></a>
Introduction</h1>
<p>The UART driver supports the UART capabilities of the USART, UART, and LEUART peripherals. The driver is fully reentrant and supports multiple driver instances. The driver does not buffer or queue data. However, it queues UART transmit and receive operations. Both blocking and non-blocking transfer functions are available. Non-blocking transfer functions report transfer completion with callback functions. Transfers are done using DMA. Simple direct/forced transmit and receive functions are also available. Note that these functions are blocking and not suitable for low energy applications because they use CPU polling.</p>
<p>UART hardware flow control (CTS/RTS) is fully supported by the driver. UART software flow control (XON/XOFF) is partially supported by the driver. For more information about flow control support, see <a class="el" href="#uartdrv_fc">Flow Control Support</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Transfer completion callback functions are called from within the DMA interrupt handler with interrupts disabled.</dd></dl>
<p><br  />
 </p>
<h1><a class="anchor" id="uartdrv_conf"></a>
Configuration Options</h1>
<p>Some properties of the UARTDRV driver are compile-time configurable. These properties are set in a <a class="el" href="uartdrv__config_8h.html" title="UARTDRV configuration file.">uartdrv_config.h</a> file. A template for this file, containing default values, is in the emdrv/config folder. To configure UARTDRV for your application, provide a custom configuration file, or override the defines on the compiler command line. These are the available configuration parameters with default values defined. </p><div class="fragment"><div class="line">  <span class="comment">// Set to 1 to enable hardware flow control.</span></div>
<div class="line"><span class="preprocessor">#define EMDRV_UARTDRV_FLOW_CONTROL_ENABLE       1</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Maximum number of driver instances.</span></div>
<div class="line"><span class="preprocessor">#define EMDRV_UARTDRV_MAX_DRIVER_INSTANCES      4</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// UART software flow control code: request peer to start Tx.</span></div>
<div class="line"><span class="preprocessor">#define UARTDRV_FC_SW_XON                       0x11</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// UART software flow control code: request peer to stop Tx.</span></div>
<div class="line"><span class="preprocessor">#define UARTDRV_FC_SW_XOFF                      0x13</span></div>
</div><!-- fragment --><p>The properties of each UART driver instance are set at run-time via the UARTDRV_InitUart_t data structure input parameter to the UARTDRV_InitUart() function for UART and USART peripherals, and the UARTDRV_InitLeuart_t data structure input parameter to the UARTDRV_InitLeuart() function for LEUART peripherals.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="uartdrv_api"></a>
The API</h1>
<p>This section contains brief descriptions of the functions in the API. For more information on input and output parameters and return values, click on the hyperlinked function names. Most functions return an error code, <a class="el" href="group__uartdrv__error__codes.html#gab58e66dca86247dadeb887240b081bfb">ECODE_EMDRV_UARTDRV_OK</a> is returned on success, see <a class="el" href="ecode_8h.html" title="Energy Aware drivers error code definitions.">ecode.h</a> and <a class="el" href="uartdrv_8h.html" title="UARTDRV API definition.">uartdrv.h</a> for other error codes.</p>
<p>The application code must include <em><a class="el" href="uartdrv_8h.html" title="UARTDRV API definition.">uartdrv.h</a></em> header file.</p>
<p>UARTDRV_InitUart(), UARTDRV_InitLeuart() and <a class="el" href="#ga3b4222031534ab6d54ca068b5fa6e596">UARTDRV_DeInit()</a> <br  />
 These functions initialize and deinitialize the UARTDRV driver. Typically, UARTDRV_InitUart() (for UART/USART) or UARTDRV_InitLeuart() (for LEUART) are called once in the startup code.</p>
<p><a class="el" href="#ga34806bf9fc4d876aa6ae725ce060541b">UARTDRV_GetReceiveStatus()</a> and <a class="el" href="#gae5387109fb659840fa822aa6ae08b81f">UARTDRV_GetTransmitStatus()</a> <br  />
 Query the status of a current transmit or receive operations. Reports number of items (frames) transmitted and remaining.</p>
<p><a class="el" href="#gab9b0230941575668b73874ffe1ff01e4">UARTDRV_GetReceiveDepth()</a> and <a class="el" href="#gab467cb6aa9940119e4f03bd860c76266">UARTDRV_GetTransmitDepth()</a> <br  />
 Get the number of queued receive or transmit operations.</p>
<p><a class="el" href="#ga484ac0b78a9eccb0ec6a1d30b7cc3232">UARTDRV_Transmit()</a>, <a class="el" href="#ga1d8a5e61c33176ad32cf3c1330e132c6" title="Start a non-blocking receive.">UARTDRV_Receive()</a> <br  />
 <a class="el" href="#ga58f8120e861e2d9335e2acceec1ae4f7" title="Start a blocking transmit.">UARTDRV_TransmitB()</a>, <a class="el" href="#ga5d8380296aa482ac95360d3855a2e150" title="Start a blocking receive.">UARTDRV_ReceiveB()</a> <br  />
 <a class="el" href="#ga762bade408c1a64812467e1f58026899" title="Direct transmit without interrupts or callback. This is a blocking function. that ignores flow contro...">UARTDRV_ForceTransmit()</a> and <a class="el" href="#gac978c9e489a78347598b3005bb49545e" title="Direct receive without interrupts or callback. This is a blocking function.">UARTDRV_ForceReceive()</a> <br  />
 Blocking and non-blocking transfer functions are included. The blocking versions have an uppercase B (for Blocking) at the end of their function name. Blocking functions do not return before the transfer is complete. The non-blocking functions signal a transfer completion with a callback function. <a class="el" href="#ga762bade408c1a64812467e1f58026899">UARTDRV_ForceTransmit()</a> and <a class="el" href="#gac978c9e489a78347598b3005bb49545e">UARTDRV_ForceReceive()</a> are also blocking. These two functions access the UART peripheral directly without using DMA or interrupts. <a class="el" href="#ga762bade408c1a64812467e1f58026899">UARTDRV_ForceTransmit()</a> does not respect flow control. <a class="el" href="#gac978c9e489a78347598b3005bb49545e">UARTDRV_ForceReceive()</a> forces RTS low.</p>
<p><a class="el" href="#ga0abd859c2a17dafe03abceeb4c96a12a">UARTDRV_Abort()</a> <br  />
 Abort current transmit or receive operations and remove all queued operations.</p>
<p><a class="el" href="#ga793738f4fce0d507867e3a56d36426d2">UARTDRV_FlowControlSet()</a>, <a class="el" href="#ga54bed0223f912f7a5a5e1c4a62356ffe">UARTDRV_FlowControlGetSelfStatus()</a>, <a class="el" href="#ga110407a69b9915d78980749b449a106c">UARTDRV_FlowControlSetPeerStatus()</a> and <a class="el" href="#ga3ba0e9be643afcefc0962dcdb2e635a7">UARTDRV_FlowControlGetPeerStatus()</a> <br  />
 Set and get flow control status of self or peer device. Note that the return value from these two functions depends on the flow control mode set by <a class="el" href="#ga793738f4fce0d507867e3a56d36426d2">UARTDRV_FlowControlSet()</a>, UARTDRV_InitUart(), or UARTDRV_InitLeuart().</p>
<p><a class="el" href="#ga8e0d51c55deaa14695b276c3c19cd4a1">UARTDRV_FlowControlIgnoreRestrain()</a> <br  />
 Enables transmission when restrained by flow control.</p>
<p><a class="el" href="#gafa7cbc80545ad814f338c4043de5023c">UARTDRV_PauseTransmit()</a> and <a class="el" href="#ga6e83c35be3ad93e6717ce8dc54a155c7">UARTDRV_ResumeTransmit()</a> <br  />
 Pause a currently active transmit operation by preventing the DMA from loading the UART FIFO. Will not override HW flow control state (if applicable), but can be used in conjunction.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="uartdrv_fc"></a>
Flow Control Support</h1>
<p>If UART flow control is not required, make sure that EMDRV_UARTDRV_FLOW_CONTROL_ENABLE is set to 0. This reduces the code size and complexity of the driver.</p>
<p>Both hardware and software flow control are supported. To enable either of these, set EMDRV_UARTDRV_FLOW_CONTROL_ENABLE to 1 in <a class="el" href="uartdrv__config_8h.html" title="UARTDRV configuration file.">uartdrv_config.h</a>.</p>
<p><br  />
 </p>
<h2><a class="anchor" id="uartdrv_fc_hw"></a>
Hardware Flow Control</h2>
<p>UART hardware flow control uses two additional pins for flow control handshaking, the clear-to-send (CTS) and ready-to-send (RTS) pins. RTS is an output and CTS is an input. These are active-low signals. When CTS is high, the UART transmitter should stop sending frames. A receiver should set RTS high when it is no longer capable of receiving data.</p>
<dl class="section user"><dt>Peripheral Hardware Flow Control</dt><dd></dd></dl>
<p>Newer devices natively support CTS/RTS in the USART peripheral hardware. To enable hardware flow control, perform the following steps:</p>
<ul>
<li>Set EMDRV_UARTDRV_FLOW_CONTROL_ENABLE to 1.</li>
<li>In the UARTDRV_InitUart_t struct passed to UARTDRV_InitUart(), set UARTDRV_InitUart_t.fcType = uartdrvFlowControlHwUart.</li>
<li>Define the pins for CTS and RTS by setting ctsPort, ctsPin, rtsPort and rtsPin in the init struct.</li>
<li>Also define the CTS and RTS locations by setting portLocationCts and portLocationRts in the init struct.</li>
</ul>
<dl class="section user"><dt>GPIO Hardware Flow Control</dt><dd></dd></dl>
<p>To support hardware flow control on devices that don't have UART CTS/RTS hardware support, the driver includes the GPIOINT driver to emulate a hardware implementation of UART CTS/RTS flow control on these devices.</p>
<p>To enable hardware flow control, perform the following steps:</p>
<ul>
<li>Set EMDRV_UARTDRV_FLOW_CONTROL_ENABLE to 1.</li>
<li>UART/USART: In the UARTDRV_InitUart_t struct passed to UARTDRV_InitUart(), set UARTDRV_InitUart_t.fcType = uartdrvFlowControlHw.</li>
<li>LEUART: In the UARTDRV_InitLeuart_t struct passed to UARTDRV_InitLeuart(), set UARTDRV_InitLeuart_t.fcType = uartdrvFlowControlHw.</li>
<li>Define the pins for CTS and RTS by setting ctsPort, ctsPin, rtsPort and rtsPin in the same init struct.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Because of the limitations in GPIO interrupt hardware, you cannot select CTS pins in multiple driver instances with the same pin number. For example, pin A0 and B0 cannot serve as CTS pins in two concurrent driver instances.</dd></dl>
<p>RTS is set high whenever there are no Rx operations queued. The UART transmitter is halted when the CTS pin goes high. The transmitter completes the current frame before halting. DMA transfers are also halted.</p>
<p><br  />
 </p>
<h2><a class="anchor" id="uartdrv_fc_sw"></a>
Software Flow Control</h2>
<p>UART software flow control uses in-band signaling, meaning the receiver sends special flow control characters to the transmitter and thereby removes the need for dedicated wires for flow control. The two symbols UARTDRV_FC_SW_XON and UARTDRV_FC_SW_XOFF are defined in <a class="el" href="uartdrv__config_8h.html" title="UARTDRV configuration file.">uartdrv_config.h</a>.</p>
<p>To enable support for software flow control, perform the following steps:</p>
<ul>
<li>Set EMDRV_UARTDRV_FLOW_CONTROL_ENABLE to 1.</li>
<li>UART/USART: In the UARTDRV_InitUart_t structure passed to UARTDRV_InitUart(), set UARTDRV_InitUart_t.fcType = uartdrvFlowControlSw.</li>
<li>LEUART: In the UARTDRV_InitLeuart_t structure passed to UARTDRV_InitLeuart(), set UARTDRV_InitLeuart_t.fcType = uartdrvFlowControlSw.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Software flow control is partial only.</dd></dl>
<p>The application must monitor buffers and make decisions on when to send XON/ XOFF. XON/XOFF can be sent to the peer using <a class="el" href="#ga793738f4fce0d507867e3a56d36426d2">UARTDRV_FlowControlSet()</a>. Though <a class="el" href="#ga793738f4fce0d507867e3a56d36426d2">UARTDRV_FlowControlSet()</a> will pause the active transmit operation to send a flow control character, there is no way to guarantee the order. If the application implements a specific packet format where the flow control codes may appear only in fixed positions, the application should not use <a class="el" href="#ga793738f4fce0d507867e3a56d36426d2">UARTDRV_FlowControlSet()</a> but implement read and write of XON/XOFF into packet buffers. If the application code fully implements all the flow control logic, EMDRV_UARTDRV_FLOW_CONTROL_ENABLE should be set to 0 to reduce code space.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="uartdrv_example"></a>
Example</h1>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga24318918f06c584749d8a2f8a96be2fc" name="ga24318918f06c584749d8a2f8a96be2fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24318918f06c584749d8a2f8a96be2fc">&#9670;&#160;</a></span>DEFINE_BUF_QUEUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_BUF_QUEUE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>qSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>qName</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keyword">typedef</span> <span class="keyword">struct </span>{                     \</div>
<div class="line">    uint16_t head;                     \</div>
<div class="line">    uint16_t tail;                     \</div>
<div class="line">    <span class="keyword">volatile</span> uint16_t used;            \</div>
<div class="line">    <span class="keyword">const</span> uint16_t size;               \</div>
<div class="line">    <a class="code hl_struct" href="struct_u_a_r_t_d_r_v___buffer__t.html">UARTDRV_Buffer_t</a> fifo[qSize];      \</div>
<div class="line">  } _##qName;                          \</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">volatile</span> _##qName qName =     \</div>
<div class="line">  {                                    \</div>
<div class="line">    .head = 0,                         \</div>
<div class="line">    .tail = 0,                         \</div>
<div class="line">    .used = 0,                         \</div>
<div class="line">    .size = qSize,                     \</div>
<div class="line">  }</div>
<div class="ttc" id="astruct_u_a_r_t_d_r_v___buffer__t_html"><div class="ttname"><a href="struct_u_a_r_t_d_r_v___buffer__t.html">UARTDRV_Buffer_t</a></div><div class="ttdoc">UART transfer buffer.</div><div class="ttdef"><b>Definition</b> uartdrv.h:191</div></div>
</div><!-- fragment --><p>Macros to define FIFO and buffer queues. typedef can't be used because the size of the FIFO array in the queues can change. </p>

</div>
</div>
<a id="gabe460e78b696ee85a78db220e5f6ec89" name="gabe460e78b696ee85a78db220e5f6ec89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe460e78b696ee85a78db220e5f6ec89">&#9670;&#160;</a></span>EMDRV_UARTDRV_MAX_CONCURRENT_RX_BUFS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EMDRV_UARTDRV_MAX_CONCURRENT_RX_BUFS&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of the receive operation queue.</p>
<p>The maximum number of receive operations that can be queued up for one driver instance before <a class="el" href="#ga1d8a5e61c33176ad32cf3c1330e132c6">UARTDRV_Receive()</a> returns <a class="el" href="group__uartdrv__error__codes.html#ga1508fd8b2237135b1b02a2b7096edac0">ECODE_EMDRV_UARTDRV_QUEUE_FULL</a>. </p><dl class="section note"><dt>Note</dt><dd>This macro is not used by the UARTDRV itself, but is intended to be used with the <a class="el" href="#ga24318918f06c584749d8a2f8a96be2fc">DEFINE_BUF_QUEUE</a> macro by the user of the driver to allocate instances of the <a class="el" href="struct_u_a_r_t_d_r_v___buffer___fifo_queue__t.html">UARTDRV_Buffer_FifoQueue_t</a> struct. </dd></dl>

</div>
</div>
<a id="ga1a5792abd05dc9ec1eb1c2fa0e9b9d6a" name="ga1a5792abd05dc9ec1eb1c2fa0e9b9d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a5792abd05dc9ec1eb1c2fa0e9b9d6a">&#9670;&#160;</a></span>EMDRV_UARTDRV_MAX_CONCURRENT_TX_BUFS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EMDRV_UARTDRV_MAX_CONCURRENT_TX_BUFS&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of the transmit operation queue.</p>
<p>The maximum number of transmit operations that can be queued up for one driver instance before <a class="el" href="#ga484ac0b78a9eccb0ec6a1d30b7cc3232">UARTDRV_Transmit()</a> returns <a class="el" href="group__uartdrv__error__codes.html#ga1508fd8b2237135b1b02a2b7096edac0">ECODE_EMDRV_UARTDRV_QUEUE_FULL</a>. </p><dl class="section note"><dt>Note</dt><dd>This macro is not used by the UARTDRV itself, but is intended to be used with the <a class="el" href="#ga24318918f06c584749d8a2f8a96be2fc">DEFINE_BUF_QUEUE</a> macro by the user of the driver to allocate instances of the <a class="el" href="struct_u_a_r_t_d_r_v___buffer___fifo_queue__t.html">UARTDRV_Buffer_FifoQueue_t</a> struct. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga75a7670b4c9deaa47bc197bbde9b7fb4" name="ga75a7670b4c9deaa47bc197bbde9b7fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75a7670b4c9deaa47bc197bbde9b7fb4">&#9670;&#160;</a></span>UARTDRV_Callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* UARTDRV_Callback_t) (struct <a class="el" href="struct_u_a_r_t_d_r_v___handle_data.html">UARTDRV_HandleData</a> *handle, <a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a> transferStatus, uint8_t *data, <a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a> transferCount)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UARTDRV transfer completion callback function. </p>
<p>Called when a transfer is complete. An application should check the transferStatus and itemsTransferred values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The UARTDRV device handle used to start the transfer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transferStatus</td><td>Completion status of the transfer operation.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A pointer to the transfer data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transferCount</td><td>A number of bytes transferred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac38a311be86450bee230b5bf111cecf3" name="gac38a311be86450bee230b5bf111cecf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac38a311be86450bee230b5bf111cecf3">&#9670;&#160;</a></span>UARTDRV_HandleData_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_a_r_t_d_r_v___handle_data.html">UARTDRV_HandleData</a> <a class="el" href="#gac38a311be86450bee230b5bf111cecf3">UARTDRV_HandleData_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A UART driver instance handle data structure. Allocated by the application using UARTDRV. Several concurrent driver instances may exist in an application. The application must not modify the contents of this handle and should not depend on its values. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0111d9b9c81c8b15cfde60ac8d19c36c" name="ga0111d9b9c81c8b15cfde60ac8d19c36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0111d9b9c81c8b15cfde60ac8d19c36c">&#9670;&#160;</a></span>SL_ENUM() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SL_ENUM </td>
          <td>(</td>
          <td class="paramtype">UARTDRV_AbortType_t</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer abort type. </p>
<p>&lt; Abort current and queued transmit operations</p>
<p>&lt; Abort current and queued receive operations</p>
<p>&lt; Abort all current and queued operations</p>

</div>
</div>
<a id="ga88d8ed44e5de7fddff07b6f98c6be21f" name="ga88d8ed44e5de7fddff07b6f98c6be21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88d8ed44e5de7fddff07b6f98c6be21f">&#9670;&#160;</a></span>SL_ENUM() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SL_ENUM </td>
          <td>(</td>
          <td class="paramtype">UARTDRV_FlowControlState_t</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flow Control state. </p>
<p>&lt; XON or nRTS/nCTS low</p>
<p>&lt; XOFF or nRTS/nCTS high</p>
<p>&lt; This driver controls the state.</p>

</div>
</div>
<a id="gadd561e294765dfb017374057fd99ceb8" name="gadd561e294765dfb017374057fd99ceb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd561e294765dfb017374057fd99ceb8">&#9670;&#160;</a></span>SL_ENUM() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SL_ENUM </td>
          <td>(</td>
          <td class="paramtype">UARTDRV_FlowControlType_t</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; None</p>
<p>&lt; Software XON/XOFF</p>
<p>&lt; nRTS/nCTS hardware handshake</p>
<p>&lt; UART peripheral controls nRTS/nCTS</p>

</div>
</div>
<a id="ga0abd859c2a17dafe03abceeb4c96a12a" name="ga0abd859c2a17dafe03abceeb4c96a12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0abd859c2a17dafe03abceeb4c96a12a">&#9670;&#160;</a></span>UARTDRV_Abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a> UARTDRV_Abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UARTDRV_AbortType_t</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort ongoing UART transfers. </p>
<p>All ongoing or queued operations of the given abort type will be aborted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Abort type &ndash; whether to abort only Tx, only Rx, or both.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__uartdrv__error__codes.html#gab58e66dca86247dadeb887240b081bfb">ECODE_EMDRV_UARTDRV_OK</a> on success, <a class="el" href="group__uartdrv__error__codes.html#ga1c71e9adb59ea02dd52b94ee2958ada4">ECODE_EMDRV_UARTDRV_IDLE</a> if the UART is idle. On failure, an appropriate UARTDRV <a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a> is returned. </dd></dl>

</div>
</div>
<a id="ga3b4222031534ab6d54ca068b5fa6e596" name="ga3b4222031534ab6d54ca068b5fa6e596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b4222031534ab6d54ca068b5fa6e596">&#9670;&#160;</a></span>UARTDRV_DeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a> UARTDRV_DeInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deinitialize a UART driver instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__uartdrv__error__codes.html#gab58e66dca86247dadeb887240b081bfb">ECODE_EMDRV_UARTDRV_OK</a> on success. On failure, an appropriate UARTDRV <a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a> is returned. </dd></dl>

</div>
</div>
<a id="ga3ba0e9be643afcefc0962dcdb2e635a7" name="ga3ba0e9be643afcefc0962dcdb2e635a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ba0e9be643afcefc0962dcdb2e635a7">&#9670;&#160;</a></span>UARTDRV_FlowControlGetPeerStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UARTDRV_FlowControlState_t UARTDRV_FlowControlGetPeerStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the peer's flow control status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns uartdrvFlowControlOn if clear to send. </dd></dl>

</div>
</div>
<a id="ga54bed0223f912f7a5a5e1c4a62356ffe" name="ga54bed0223f912f7a5a5e1c4a62356ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54bed0223f912f7a5a5e1c4a62356ffe">&#9670;&#160;</a></span>UARTDRV_FlowControlGetSelfStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UARTDRV_FlowControlState_t UARTDRV_FlowControlGetSelfStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the self flow control status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns uartdrvFlowControlOn if requesting to send. </dd></dl>

</div>
</div>
<a id="ga8e0d51c55deaa14695b276c3c19cd4a1" name="ga8e0d51c55deaa14695b276c3c19cd4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e0d51c55deaa14695b276c3c19cd4a1">&#9670;&#160;</a></span>UARTDRV_FlowControlIgnoreRestrain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a> UARTDRV_FlowControlIgnoreRestrain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable transmission when restrained by flow control. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__uartdrv__error__codes.html#gab58e66dca86247dadeb887240b081bfb">ECODE_EMDRV_UARTDRV_OK</a> on success. </dd></dl>

</div>
</div>
<a id="ga793738f4fce0d507867e3a56d36426d2" name="ga793738f4fce0d507867e3a56d36426d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga793738f4fce0d507867e3a56d36426d2">&#9670;&#160;</a></span>UARTDRV_FlowControlSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a> UARTDRV_FlowControlSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UARTDRV_FlowControlState_t</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set UART flow control state. Set nRTS pin if hardware flow control is enabled. Send XON/XOFF if software flow control is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Flow control state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__uartdrv__error__codes.html#gab58e66dca86247dadeb887240b081bfb">ECODE_EMDRV_UARTDRV_OK</a> on success. </dd></dl>

</div>
</div>
<a id="ga110407a69b9915d78980749b449a106c" name="ga110407a69b9915d78980749b449a106c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga110407a69b9915d78980749b449a106c">&#9670;&#160;</a></span>UARTDRV_FlowControlSetPeerStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a> UARTDRV_FlowControlSetPeerStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UARTDRV_FlowControlState_t</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set peer UART flow control state. Pause/resume transmit accordingly. Only for manual software flow control. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Flow control state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__uartdrv__error__codes.html#gab58e66dca86247dadeb887240b081bfb">ECODE_EMDRV_UARTDRV_OK</a> on success. </dd></dl>

</div>
</div>
<a id="gac978c9e489a78347598b3005bb49545e" name="gac978c9e489a78347598b3005bb49545e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac978c9e489a78347598b3005bb49545e">&#9670;&#160;</a></span>UARTDRV_ForceReceive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a> UARTDRV_ForceReceive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a></td>          <td class="paramname"><span class="paramname"><em>maxCount</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct receive without interrupts or callback. This is a blocking function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>pointer to buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxCount</td><td>Maximum number of bytes to receive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes received. </dd></dl>

</div>
</div>
<a id="ga762bade408c1a64812467e1f58026899" name="ga762bade408c1a64812467e1f58026899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga762bade408c1a64812467e1f58026899">&#9670;&#160;</a></span>UARTDRV_ForceTransmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a> UARTDRV_ForceTransmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct transmit without interrupts or callback. This is a blocking function. that ignores flow control if enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>A number of bytes to transmit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__uartdrv__error__codes.html#gab58e66dca86247dadeb887240b081bfb">ECODE_EMDRV_UARTDRV_OK</a> on success. </dd></dl>

</div>
</div>
<a id="ga38e53b4e39e17d0f7be9034ef11eb534" name="ga38e53b4e39e17d0f7be9034ef11eb534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38e53b4e39e17d0f7be9034ef11eb534">&#9670;&#160;</a></span>UARTDRV_GetPeripheralStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#gae1cf3e2748cf7a377fe60f055c07c3a6">UARTDRV_Status_t</a> UARTDRV_GetPeripheralStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status of the UART peripheral associated with a given handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UART status value </dd></dl>

</div>
</div>
<a id="gab9b0230941575668b73874ffe1ff01e4" name="gab9b0230941575668b73874ffe1ff01e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9b0230941575668b73874ffe1ff01e4">&#9670;&#160;</a></span>UARTDRV_GetReceiveDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t UARTDRV_GetReceiveDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of queued receive operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of queued operations. </dd></dl>

</div>
</div>
<a id="ga34806bf9fc4d876aa6ae725ce060541b" name="ga34806bf9fc4d876aa6ae725ce060541b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34806bf9fc4d876aa6ae725ce060541b">&#9670;&#160;</a></span>UARTDRV_GetReceiveStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#gae1cf3e2748cf7a377fe60f055c07c3a6">UARTDRV_Status_t</a> UARTDRV_GetReceiveStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a> *</td>          <td class="paramname"><span class="paramname"><em>itemsReceived</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a> *</td>          <td class="paramname"><span class="paramname"><em>itemsRemaining</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the status of the UART and gather information about any ongoing receive operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Pointer to the current data buffer.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">itemsReceived</td><td>Current bytes received count.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">itemsRemaining</td><td>Current bytes remaining count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UART status. </dd></dl>

</div>
</div>
<a id="gab467cb6aa9940119e4f03bd860c76266" name="gab467cb6aa9940119e4f03bd860c76266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab467cb6aa9940119e4f03bd860c76266">&#9670;&#160;</a></span>UARTDRV_GetTransmitDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t UARTDRV_GetTransmitDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of queued transmit operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of queued operations. </dd></dl>

</div>
</div>
<a id="gae5387109fb659840fa822aa6ae08b81f" name="gae5387109fb659840fa822aa6ae08b81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5387109fb659840fa822aa6ae08b81f">&#9670;&#160;</a></span>UARTDRV_GetTransmitStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#gae1cf3e2748cf7a377fe60f055c07c3a6">UARTDRV_Status_t</a> UARTDRV_GetTransmitStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t **</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a> *</td>          <td class="paramname"><span class="paramname"><em>itemsSent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a> *</td>          <td class="paramname"><span class="paramname"><em>itemsRemaining</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the status of the UART and gather information about any ongoing transmit operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Pointer to the current data buffer.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">itemsSent</td><td>Current bytes sent count.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">itemsRemaining</td><td>Current bytes remaining count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UART status. </dd></dl>

</div>
</div>
<a id="gafa7cbc80545ad814f338c4043de5023c" name="gafa7cbc80545ad814f338c4043de5023c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa7cbc80545ad814f338c4043de5023c">&#9670;&#160;</a></span>UARTDRV_PauseTransmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a> UARTDRV_PauseTransmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause an ongoing transmit operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__uartdrv__error__codes.html#gab58e66dca86247dadeb887240b081bfb">ECODE_EMDRV_UARTDRV_OK</a> on success. On failure, an appropriate UARTDRV <a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a> is returned. </dd></dl>

</div>
</div>
<a id="ga1d8a5e61c33176ad32cf3c1330e132c6" name="ga1d8a5e61c33176ad32cf3c1330e132c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d8a5e61c33176ad32cf3c1330e132c6">&#9670;&#160;</a></span>UARTDRV_Receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a> UARTDRV_Receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga75a7670b4c9deaa47bc197bbde9b7fb4">UARTDRV_Callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a non-blocking receive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A receive data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>A number of bytes received.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A transfer completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__uartdrv__error__codes.html#gab58e66dca86247dadeb887240b081bfb">ECODE_EMDRV_UARTDRV_OK</a> on success. </dd></dl>

</div>
</div>
<a id="ga5d8380296aa482ac95360d3855a2e150" name="ga5d8380296aa482ac95360d3855a2e150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d8380296aa482ac95360d3855a2e150">&#9670;&#160;</a></span>UARTDRV_ReceiveB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a> UARTDRV_ReceiveB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a blocking receive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A receive data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>A number of bytes received.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__uartdrv__error__codes.html#gab58e66dca86247dadeb887240b081bfb">ECODE_EMDRV_UARTDRV_OK</a> on success. </dd></dl>

</div>
</div>
<a id="ga6e83c35be3ad93e6717ce8dc54a155c7" name="ga6e83c35be3ad93e6717ce8dc54a155c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e83c35be3ad93e6717ce8dc54a155c7">&#9670;&#160;</a></span>UARTDRV_ResumeTransmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a> UARTDRV_ResumeTransmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume a paused transmit operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__uartdrv__error__codes.html#gab58e66dca86247dadeb887240b081bfb">ECODE_EMDRV_UARTDRV_OK</a> on success. On failure, an appropriate UARTDRV <a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a> is returned. </dd></dl>

</div>
</div>
<a id="ga484ac0b78a9eccb0ec6a1d30b7cc3232" name="ga484ac0b78a9eccb0ec6a1d30b7cc3232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga484ac0b78a9eccb0ec6a1d30b7cc3232">&#9670;&#160;</a></span>UARTDRV_Transmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a> UARTDRV_Transmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga75a7670b4c9deaa47bc197bbde9b7fb4">UARTDRV_Callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a non-blocking transmit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A transmit data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>A number of bytes to transmit.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A transfer completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__uartdrv__error__codes.html#gab58e66dca86247dadeb887240b081bfb">ECODE_EMDRV_UARTDRV_OK</a> on success. </dd></dl>

</div>
</div>
<a id="ga58f8120e861e2d9335e2acceec1ae4f7" name="ga58f8120e861e2d9335e2acceec1ae4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58f8120e861e2d9335e2acceec1ae4f7">&#9670;&#160;</a></span>UARTDRV_TransmitB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ecode.html#ga7bf5621660c5ba69ac4dd3044173d35c">Ecode_t</a> UARTDRV_TransmitB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga559d69d7978a815087a905fb13af15ea">UARTDRV_Handle_t</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga20f2dca466c884ed896061f8e90ff816">UARTDRV_Count_t</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a blocking transmit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Pointer to a UART driver handle.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A transmit data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>A number of bytes to transmit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__uartdrv__error__codes.html#gab58e66dca86247dadeb887240b081bfb">ECODE_EMDRV_UARTDRV_OK</a> on success. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
